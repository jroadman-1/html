<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Shop Layout Planner</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      background: #f5f5f5;
    }

    header {
      padding: 8px 12px;
      background: #333;
      color: #fff;
      font-size: 18px;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      padding: 10px 12px;
      background: #fafafa;
      border-bottom: 1px solid #ddd;
    }

    .control-group {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      font-size: 14px;
    }

    label {
      font-weight: 500;
    }

    input[type="number"],
    input[type="text"],
    select {
      padding: 3px 6px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #bbb;
      min-width: 60px;
    }

    button {
      padding: 4px 10px;
      font-size: 13px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #fff;
      cursor: pointer;
    }

    button:hover {
      background: #eee;
    }

    #main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 8px 12px 12px 12px;
      box-sizing: border-box;
      gap: 8px;
      position: relative;
    }

    #canvasContainer {
      flex: 1;
      border: 1px solid #ccc;
      background: #fff;
      position: relative;
    }

    #layoutCanvas {
      width: 100%;
      height: 100%;
      display: block;
      outline: none;
    }

    .hint {
      font-size: 12px;
      color: #555;
    }

    #itemEditor {
      position: absolute;
      background: #ffffff;
      border: 1px solid #999;
      border-radius: 6px;
      padding: 6px 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      font-size: 12px;
      z-index: 10;
      display: none;
    }

    #itemEditor h4 {
      margin: 0 0 4px 0;
      font-size: 12px;
      font-weight: 600;
    }

    #itemEditor input[type="text"],
    #itemEditor input[type="number"] {
      font-size: 12px;
      padding: 2px 4px;
      margin-bottom: 3px;
      width: 90px;
    }

    #itemEditor button {
      font-size: 11px;
      padding: 2px 6px;
      margin-right: 4px;
    }

    @media print {
      body {
        margin: 0;
        padding: 0;
        background: #fff;
      }

      header, .controls, .hint, #itemEditor {
        display: none !important;
      }

      #main {
        padding: 0;
      }

      #canvasContainer {
        border: none;
      }

      #layoutCanvas {
        width: 100vw;
        height: 100vh;
      }
    }
  </style>
</head>
<body>
<header>Shop Layout Planner</header>

<div class="controls">
  <div class="control-group">
    <label for="roomWidth">Room Width:</label>
    <input type="number" id="roomWidth" value="20" min="1" step="0.1">
    <label for="roomHeight">Room Height:</label>
    <input type="number" id="roomHeight" value="30" min="1" step="0.1">
    <select id="roomUnits">
      <option value="ft">Feet</option>
      <option value="m">Meters</option>
    </select>
    <button id="applyRoomBtn">Apply Room</button>
  </div>

  <div class="control-group">
    <label for="itemName">Item:</label>
    <input type="text" id="itemName" placeholder="Tablesaw" size="10">
    <label for="itemWidth">W:</label>
    <input type="number" id="itemWidth" value="3" min="0.1" step="0.1">
    <label for="itemDepth">D:</label>
    <input type="number" id="itemDepth" value="2" min="0.1" step="0.1">
    <span id="itemUnitsLabel">ft</span>
    <button id="addItemBtn">Add Item</button>
  </div>

  <div class="control-group">
    <button id="saveBtn">Save Layout (Browser)</button>
    <button id="loadBtn">Load Layout (Browser)</button>
    <button id="downloadBtn">Download Layout</button>
    <button id="uploadBtn">Upload Layout</button>
    <button id="printBtn">Print / PDF</button>
    <input type="file" id="fileInput" accept="application/json" style="display:none;">
  </div>
</div>

<div id="main">
  <div id="canvasContainer">
    <canvas id="layoutCanvas" tabindex="0"></canvas>
  </div>

  <div id="itemEditor">
    <h4>Edit Item</h4>
    <div>
      <label>Name:</label><br>
      <input type="text" id="editName">
    </div>
    <div>
      <label>Width:</label><br>
      <input type="number" id="editWidth" step="0.1" min="0.1">
    </div>
    <div>
      <label>Depth:</label><br>
      <input type="number" id="editDepth" step="0.1" min="0.1">
    </div>
    <div style="margin-top:4px;">
      <button id="applyEditBtn">Apply</button>
      <button id="deleteItemBtn" style="border-color:#b00;color:#b00;">Delete</button>
    </div>
  </div>

  <div class="hint">
    <strong>Controls:</strong>
    Click an item to select. Drag inside the item to move it.
    Drag the small circle above a selected item to rotate.
    Use <code>[</code> / <code>]</code> to rotate with the keyboard (snaps near 0°, 90°, 180°, 270°).
  </div>
</div>

<script>
  const canvas = document.getElementById('layoutCanvas');
  const ctx = canvas.getContext('2d');

  const roomWidthInput = document.getElementById('roomWidth');
  const roomHeightInput = document.getElementById('roomHeight');
  const roomUnitsSelect = document.getElementById('roomUnits');
  const applyRoomBtn = document.getElementById('applyRoomBtn');

  const itemNameInput = document.getElementById('itemName');
  const itemWidthInput = document.getElementById('itemWidth');
  const itemDepthInput = document.getElementById('itemDepth');
  const itemUnitsLabel = document.getElementById('itemUnitsLabel');
  const addItemBtn = document.getElementById('addItemBtn');

  const saveBtn = document.getElementById('saveBtn');
  const loadBtn = document.getElementById('loadBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const uploadBtn = document.getElementById('uploadBtn');
  const fileInput = document.getElementById('fileInput');
  const printBtn = document.getElementById('printBtn');

  const itemEditor = document.getElementById('itemEditor');
  const editNameInput = document.getElementById('editName');
  const editWidthInput = document.getElementById('editWidth');
  const editDepthInput = document.getElementById('editDepth');
  const applyEditBtn = document.getElementById('applyEditBtn');
  const deleteItemBtn = document.getElementById('deleteItemBtn');

  // Room & scale
  let room = {
    width: 20,  // in current units
    height: 30,
    units: 'ft'
  };

  let scale = 10; // pixels per unit (computed)
  const padding = 30; // canvas padding inside border

  // Items
  let items = [];
  let nextItemId = 1;
  let selectedItemId = null;

  // Interaction state
  let isDragging = false;
  let dragItemId = null;
  let dragOffset = { x: 0, y: 0 }; // in room units

  let isRotating = false;
  let rotateItemId = null;
  let rotateStartAngle = 0; // radians
  let rotateStartMouseAngle = 0; // radians

  // Resize canvas to container
  function resizeCanvas() {
    const rect = document.getElementById('canvasContainer').getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    computeScale();
    draw();
  }

  function computeScale() {
    if (room.width <= 0 || room.height <= 0) {
      scale = 10;
      return;
    }
    const usableWidth = canvas.width - padding * 2;
    const usableHeight = canvas.height - padding * 2;
    scale = Math.min(usableWidth / room.width, usableHeight / room.height);
  }

  function roomToCanvas(x, y) {
    return {
      x: padding + x * scale,
      y: padding + y * scale
    };
  }

  function canvasToRoom(px, py) {
    return {
      x: (px - padding) / scale,
      y: (py - padding) / scale
    };
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Background
    ctx.fillStyle = '#fdfdfd';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw room border
    ctx.save();
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 2;
    const topLeft = roomToCanvas(0, 0);
    const bottomRight = roomToCanvas(room.width, room.height);
    ctx.strokeRect(topLeft.x, topLeft.y,
      bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
    ctx.restore();

    drawGrid();
    drawItems();
    updateItemEditorPosition();
  }

  function drawGrid() {
    const majorSpacing = 1;    // 1 foot (or 1 unit)
    const minorSpacing = 0.25; // 0.25 unit (3 inches if ft)

    ctx.save();
    ctx.lineWidth = 1;

    // Minor grid
    ctx.strokeStyle = '#e3e3e3';
    ctx.beginPath();
    for (let x = 0; x <= room.width; x += minorSpacing) {
      const p1 = roomToCanvas(x, 0);
      const p2 = roomToCanvas(x, room.height);
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
    }
    for (let y = 0; y <= room.height; y += minorSpacing) {
      const p1 = roomToCanvas(0, y);
      const p2 = roomToCanvas(room.width, y);
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
    }
    ctx.stroke();

    // Major grid
    ctx.strokeStyle = '#c1c1c1';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    for (let x = 0; x <= room.width; x += majorSpacing) {
      const p1 = roomToCanvas(x, 0);
      const p2 = roomToCanvas(x, room.height);
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
    }
    for (let y = 0; y <= room.height; y += majorSpacing) {
      const p1 = roomToCanvas(0, y);
      const p2 = roomToCanvas(room.width, y);
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
    }
    ctx.stroke();

    ctx.restore();
  }

  function drawItems() {
    for (const item of items) {
      drawItem(item);
    }
  }

  function drawItem(item) {
    const center = roomToCanvas(item.x, item.y);
    const wPx = item.width * scale;
    const hPx = item.depth * scale;
    const handleOffset = 15;
    const handleRadius = 7;

    ctx.save();
    ctx.translate(center.x, center.y);
    ctx.rotate(item.rotation);

    // Body
    ctx.fillStyle = '#d5e8ff';
    ctx.strokeStyle = (item.id === selectedItemId) ? '#0066cc' : '#555';
    ctx.lineWidth = (item.id === selectedItemId) ? 2 : 1.2;
    ctx.beginPath();
    ctx.rect(-wPx / 2, -hPx / 2, wPx, hPx);
    ctx.fill();
    ctx.stroke();

    // Label (keep upright)
    ctx.fillStyle = '#000';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.save();
    ctx.rotate(-item.rotation);
    ctx.fillText(item.name, 0, 0);
    ctx.restore();

    ctx.restore();

    // Rotation handle (draw in canvas space)
    if (item.id === selectedItemId) {
      const halfH = hPx / 2;
      const L = halfH + handleOffset;
      // local direction (0, -L) rotated by item.rotation:
      const hx = center.x + L * Math.sin(item.rotation);
      const hy = center.y - L * Math.cos(item.rotation);

      ctx.save();
      ctx.fillStyle = '#ffffff';
      ctx.strokeStyle = '#0066cc';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(hx, hy, handleRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // small arrow-ish line from center to handle
      ctx.beginPath();
      ctx.moveTo(center.x, center.y);
      ctx.lineTo(hx, hy);
      ctx.stroke();
      ctx.restore();
    }
  }

  function addItem() {
    const name = itemNameInput.value.trim() || 'Item ' + nextItemId;
    const w = parseFloat(itemWidthInput.value);
    const d = parseFloat(itemDepthInput.value);
    if (!(w > 0) || !(d > 0)) {
      alert('Please enter valid item dimensions.');
      return;
    }

    const newItem = {
      id: nextItemId++,
      name,
      width: w,
      depth: d,
      x: room.width / 2,
      y: room.height / 2,
      rotation: 0
    };
    items.push(newItem);
    selectedItemId = newItem.id;
    draw();
  }

  function getItemAtCanvasPoint(px, py) {
    // check from topmost down
    for (let i = items.length - 1; i >= 0; i--) {
      const item = items[i];
      if (isPointOnRotateHandle(px, py, item)) {
        return { item, mode: 'rotate' };
      }
      if (isPointInItem(px, py, item)) {
        return { item, mode: 'move' };
      }
    }
    return null;
  }

  function isPointInItem(px, py, item) {
    const center = roomToCanvas(item.x, item.y);
    const dx = px - center.x;
    const dy = py - center.y;

    const cos = Math.cos(-item.rotation);
    const sin = Math.sin(-item.rotation);

    const lx = dx * cos - dy * sin;
    const ly = dx * sin + dy * cos;

    const halfW = item.width * scale / 2;
    const halfH = item.depth * scale / 2;

    return (lx >= -halfW && lx <= halfW && ly >= -halfH && ly <= halfH);
  }

  function isPointOnRotateHandle(px, py, item) {
    const center = roomToCanvas(item.x, item.y);
    const wPx = item.width * scale;
    const hPx = item.depth * scale;
    const halfH = hPx / 2;
    const handleOffset = 15;
    const handleRadius = 9;

    const L = halfH + handleOffset;
    const hx = center.x + L * Math.sin(item.rotation);
    const hy = center.y - L * Math.cos(item.rotation);

    const dx = px - hx;
    const dy = py - hy;
    const dist = Math.sqrt(dx * dx + dy * dy);
    return dist <= handleRadius;
  }

  // Mouse events
  canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const px = e.clientX - rect.left;
    const py = e.clientY - rect.top;

    const hit = getItemAtCanvasPoint(px, py);
    if (hit && hit.item) {
      selectedItemId = hit.item.id;
      const item = hit.item;

      if (hit.mode === 'move') {
        const roomPt = canvasToRoom(px, py);
        dragOffset.x = roomPt.x - item.x;
        dragOffset.y = roomPt.y - item.y;
        dragItemId = item.id;
        isDragging = true;
        isRotating = false;
        rotateItemId = null;
      } else if (hit.mode === 'rotate') {
        const center = roomToCanvas(item.x, item.y);
        rotateItemId = item.id;
        isRotating = true;
        isDragging = false;
        dragItemId = null;

        rotateStartAngle = item.rotation;
        rotateStartMouseAngle = Math.atan2(py - center.y, px - center.x);
      }
      draw();
    } else {
      selectedItemId = null;
      isDragging = false;
      dragItemId = null;
      isRotating = false;
      rotateItemId = null;
      draw();
    }

    canvas.focus();
  });

  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const px = e.clientX - rect.left;
    const py = e.clientY - rect.top;

    if (isDragging && dragItemId != null) {
      const item = items.find(it => it.id === dragItemId);
      if (!item) return;

      const roomPt = canvasToRoom(px, py);
      item.x = roomPt.x - dragOffset.x;
      item.y = roomPt.y - dragOffset.y;

      // keep roughly inside room
      item.x = Math.max(item.width / 2, Math.min(room.width - item.width / 2, item.x));
      item.y = Math.max(item.depth / 2, Math.min(room.height - item.depth / 2, item.y));

      draw();
    } else if (isRotating && rotateItemId != null) {
      const item = items.find(it => it.id === rotateItemId);
      if (!item) return;

      const center = roomToCanvas(item.x, item.y);
      const currentMouseAngle = Math.atan2(py - center.y, px - center.x);
      let delta = currentMouseAngle - rotateStartMouseAngle;
      item.rotation = rotateStartAngle + delta;
      snapRotation(item);
      draw();
    }
  });

  window.addEventListener('mouseup', () => {
    isDragging = false;
    dragItemId = null;
    isRotating = false;
    rotateItemId = null;
  });

  // Keyboard rotation
  document.addEventListener('keydown', (e) => {
    if (!selectedItemId) return;
    const item = items.find(it => it.id === selectedItemId);
    if (!item) return;

    const stepDeg = 5;
    const stepRad = stepDeg * Math.PI / 180;

    if (e.key === '[') {
      item.rotation -= stepRad;
      snapRotation(item);
      draw();
      e.preventDefault();
    } else if (e.key === ']') {
      item.rotation += stepRad;
      snapRotation(item);
      draw();
      e.preventDefault();
    }
  });

  function snapRotation(item) {
    // Snap to 0, 90, 180, 270 when within 5 degrees
    const snapAngles = [0, 90, 180, 270].map(a => a * Math.PI / 180);
    let angle = item.rotation;

    // normalize [0, 2π)
    angle = angle % (2 * Math.PI);
    if (angle < 0) angle += 2 * Math.PI;

    let closest = angle;
    let minDiff = Infinity;
    for (const target of snapAngles) {
      let diff = Math.abs(angle - target);
      diff = Math.min(diff, 2 * Math.PI - diff);
      if (diff < minDiff) {
        minDiff = diff;
        closest = target;
      }
    }

    const threshold = 5 * Math.PI / 180; // 5 degrees
    if (minDiff < threshold) {
      angle = closest;
    }

    item.rotation = angle;
  }

  // Room & item controls
  applyRoomBtn.addEventListener('click', () => {
    const w = parseFloat(roomWidthInput.value);
    const h = parseFloat(roomHeightInput.value);
    const units = roomUnitsSelect.value;
    if (!(w > 0) || !(h > 0)) {
      alert('Please enter valid room dimensions.');
      return;
    }
    room.width = w;
    room.height = h;
    room.units = units;
    itemUnitsLabel.textContent = (units === 'ft' ? 'ft' : units);
    computeScale();
    draw();
  });

  roomUnitsSelect.addEventListener('change', () => {
    itemUnitsLabel.textContent = (roomUnitsSelect.value === 'ft' ? 'ft' : roomUnitsSelect.value);
  });

  addItemBtn.addEventListener('click', addItem);

  // Floating editor
  function updateItemEditorPosition() {
    const item = items.find(it => it.id === selectedItemId);
    if (!item) {
      itemEditor.style.display = 'none';
      return;
    }

    // set values
    editNameInput.value = item.name;
    editWidthInput.value = item.width.toFixed(2).replace(/\.00$/, '');
    editDepthInput.value = item.depth.toFixed(2).replace(/\.00$/, '');

    // position near item center
    const center = roomToCanvas(item.x, item.y);
    let left = center.x + 14;
    let top = center.y + 14;

    // keep inside main container bounds a bit
    const mainRect = document.getElementById('main').getBoundingClientRect();
    const editorRect = itemEditor.getBoundingClientRect();

    if (left + editorRect.width > mainRect.width - 10) {
      left = center.x - editorRect.width - 14;
    }
    if (top + editorRect.height > mainRect.height - 10) {
      top = center.y - editorRect.height - 14;
    }

    itemEditor.style.left = left + 'px';
    itemEditor.style.top = top + 'px';
    itemEditor.style.display = 'block';
  }

  applyEditBtn.addEventListener('click', () => {
    const item = items.find(it => it.id === selectedItemId);
    if (!item) return;

    const newName = editNameInput.value.trim() || item.name;
    const newW = parseFloat(editWidthInput.value);
    const newD = parseFloat(editDepthInput.value);

    if (!(newW > 0) || !(newD > 0)) {
      alert('Please enter valid width and depth.');
      return;
    }

    item.name = newName;
    item.width = newW;
    item.depth = newD;

    // keep inside room
    item.x = Math.max(item.width / 2, Math.min(room.width - item.width / 2, item.x));
    item.y = Math.max(item.depth / 2, Math.min(room.height - item.depth / 2, item.y));

    draw();
  });

  deleteItemBtn.addEventListener('click', () => {
    if (!selectedItemId) return;
    items = items.filter(it => it.id !== selectedItemId);
    selectedItemId = null;
    draw();
  });

  // Save / Load (browser localStorage)
  function saveLayoutLocal() {
    const data = {
      version: 1,
      room,
      items,
      nextItemId
    };
    try {
      localStorage.setItem('shopLayout', JSON.stringify(data));
      alert('Layout saved in this browser.');
    } catch (err) {
      console.error(err);
      alert('Unable to save layout (localStorage error).');
    }
  }

  function loadLayoutLocal() {
    const raw = localStorage.getItem('shopLayout');
    if (!raw) {
      alert('No saved layout found in this browser.');
      return;
    }
    try {
      const data = JSON.parse(raw);
      restoreLayoutFromData(data);
    } catch (err) {
      console.error(err);
      alert('Error loading layout.');
    }
  }

  function restoreLayoutFromData(data) {
    room = data.room || room;
    items = data.items || [];
    nextItemId = data.nextItemId || (items.reduce((m, it) => Math.max(m, it.id), 0) + 1);

    roomWidthInput.value = room.width;
    roomHeightInput.value = room.height;
    roomUnitsSelect.value = room.units || 'ft';
    itemUnitsLabel.textContent = (room.units === 'ft' ? 'ft' : room.units);

    computeScale();
    selectedItemId = null;
    draw();
  }

  saveBtn.addEventListener('click', saveLayoutLocal);
  loadBtn.addEventListener('click', loadLayoutLocal);

  // Download / Upload
  function downloadLayoutFile() {
    const data = {
      version: 1,
      room,
      items,
      nextItemId
    };
    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    const dateStr = new Date().toISOString().slice(0,10);
    a.href = url;
    a.download = `shop_layout_${dateStr}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  function uploadLayoutFile() {
    fileInput.click();
  }

  fileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (evt) => {
      try {
        const data = JSON.parse(evt.target.result);
        restoreLayoutFromData(data);
      } catch (err) {
        console.error(err);
        alert('Error reading layout file.');
      }
    };
    reader.readAsText(file);
    // reset input so you can upload same file again if needed
    fileInput.value = '';
  });

  downloadBtn.addEventListener('click', downloadLayoutFile);
  uploadBtn.addEventListener('click', uploadLayoutFile);

  // Print
  printBtn.addEventListener('click', () => {
    window.print();
  });

  // Init
  window.addEventListener('resize', resizeCanvas);

  // Initial setup
  resizeCanvas();
  draw();
</script>

</body>
</html>
