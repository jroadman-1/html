<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Shop Layout Planner</title>
<style>
  body {
    font-family: system-ui, sans-serif;
    margin: 0;
    padding: 0;
    height: 100vh;
    display: flex;
    flex-direction: column;
    background: #f5f5f5;
  }

  header {
    padding: 8px 12px;
    background: #333;
    color: #fff;
    font-size: 18px;
  }

  /* Top controls container */
  .controls {
    display: flex;
    flex-direction: column;
    gap: 6px;
    padding: 10px 12px;
    background: #fafafa;
    border-bottom: 1px solid #ddd;
  }

  .controls-row {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 12px;
  }

  .row-left {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    align-items: center;
  }

  .row-right {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 6px;
    justify-content: flex-start;
    text-align: left;
    align-items: center;
  }

  button, input, select {
    border-radius: 4px;
    border: 1px solid #888;
    padding: 4px 6px;
    font-size: 14px;
  }
  button:hover { background: #eee; }

  button.active {
    background: #ddd;
    border-color: #555;
  }

  /* Layout: canvas left, sidebar right */
  #main {
    flex: 1;
    display: flex;
    flex-direction: row;
    overflow: hidden;
  }

  #canvasContainer {
    flex: 1;
    min-width: 300px;
    border-right: 1px solid #ccc;
    background: #fff;
    display: flex;
    position: relative;
  }

  #layoutCanvas {
    flex: 1;
    display: block;
    width: 100%;
    height: 100%;
    outline: none;
  }

  /* Sidebar */
  #sidebar {
    width: 260px;
    flex-shrink: 0;
    background: #f9f9f9;
    border-left: 1px solid #ccc;
    padding: 12px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  #sidebar h3 {
    font-size: 16px;
    margin: 0 0 6px 0;
  }

  #sidebar input[type="text"],
  #sidebar input[type="number"] {
    width: 100%;
    padding: 4px;
    margin-bottom: 6px;
    font-size: 13px;
  }

  #sidebar button {
    width: 100%;
    padding: 6px;
    margin-top: 4px;
    font-size: 13px;
  }

  #sidebar .danger {
    border-color: #b00;
    color: #b00;
  }

  .hint {
    padding: 6px 10px;
    font-size: 12px;
    color: #444;
    border-top: 1px solid #ddd;
    background: #fafafa;
  }

  @media print {
    header, .controls, #sidebar, .hint {
      display: none !important;
    }
    #canvasContainer {
      border: none;
    }
    #layoutCanvas {
      width: auto !important;
      height: auto !important;
    }
  }
</style>
</head>
<body>

<header>Shop Layout Planner</header>

<!-- Controls -->
<div class="controls">
  <!-- Row 1: Room (left) / Rect (right) -->
  <div class="controls-row">
    <div class="row-left">
      <label>Room W:</label>
      <input type="number" id="roomWidth" value="20" step="any">
      <label>H:</label>
      <input type="number" id="roomHeight" value="30" step="any">
      <select id="roomUnits">
        <option value="ft">Feet</option>
        <option value="m">Meters</option>
      </select>
      <button id="applyRoomBtn">Apply Room</button>
    </div>

    <div class="row-right">
      <label>Rect:</label>
      <input type="text" id="itemName" placeholder="Tablesaw" size="10">
      <label>W:</label>
      <input type="number" id="itemWidth" value="3" step="any">
      <label>D:</label>
      <input type="number" id="itemDepth" value="2" step="any">
      <button id="addItemBtn">Add Rect</button>
    </div>
  </div>

  <!-- Row 2: Save/PDF (left) / Circle (right) -->
  <div class="controls-row">
    <div class="row-left">
      <button id="downloadBtn">Download JSON</button>
      <button id="uploadBtn">Upload JSON</button>
      <input type="file" id="fileInput" accept="application/json" style="display:none;">
      <label>PDF Header:</label>
      <input type="text" id="pdfHeader" value="Shop Layout">
      <button id="pdfBtn">Save PDF</button>
    </div>

    <div class="row-right">
      <label>Circle:</label>
      <input type="text" id="circleName" placeholder="Drill Press" size="10">
      <label>Dia:</label>
      <input type="number" id="circleDiameter" value="2" step="any">
      <button id="addCircleBtn">Add Circle</button>
    </div>
  </div>

  <!-- Row 3: Tools (left) / Wall Type (right) -->
  <div class="controls-row">
    <div class="row-left">
      <label>Tool:</label>
      <button id="toolSelectBtn" class="active">Select / Items</button>
      <button id="toolWallBtn">Add Wall</button>
      <button id="toolLabelBtn">Add Label</button>
      <!-- Door tool will be added in a later revision -->
    </div>
    <div class="row-right">
      <label>Wall Type:</label>
      <label><input type="radio" name="wallType" value="interior" checked>Interior</label>
      <label><input type="radio" name="wallType" value="exterior">Exterior</label>
    </div>
  </div>
</div>

<!-- Main layout -->
<div id="main">
  <!-- Canvas -->
  <div id="canvasContainer">
    <canvas id="layoutCanvas" tabindex="0"></canvas>
  </div>

  <!-- Sidebar -->
  <div id="sidebar">
    <h3 id="sidebarTitle">Nothing Selected</h3>

    <div id="noSelection"><p>No item, wall, or label selected.</p></div>

    <!-- Item editor -->
    <div id="itemEditor" style="display:none;">
      <label>Name:</label>
      <input type="text" id="editName">

      <!-- Rectangle fields -->
      <div id="rectFields">
        <label>Width:</label>
        <input type="number" id="editWidth" step="any">

        <label>Depth:</label>
        <input type="number" id="editDepth" step="any">

        <label>Rotation (deg):</label>
        <input type="number" id="editRotation" step="any">
      </div>

      <!-- Circle fields -->
      <div id="circleFields" style="display:none;">
        <label>Diameter:</label>
        <input type="number" id="editDiameter" step="any">
      </div>

      <!-- Color fields -->
      <div id="colorFields">
        <label>Color:</label><br>
        <label><input type="radio" name="editColor" value="blue">Blue</label>
        <label><input type="radio" name="editColor" value="green">Green</label>
        <label><input type="radio" name="editColor" value="orange">Orange</label>
        <label><input type="radio" name="editColor" value="gray">Gray</label>
      </div>

      <button id="applyEditBtn">Apply Changes</button>
      <button id="deleteItemBtn" class="danger">Delete Item</button>
    </div>

    <!-- Wall editor -->
    <div id="wallEditor" style="display:none;">
      <label>Wall Type:</label><br>
      <label><input type="radio" name="wallEditType" value="interior"> Interior</label><br>
      <label><input type="radio" name="wallEditType" value="exterior"> Exterior</label><br><br>

      <button id="applyWallEditBtn">Apply Changes</button>
      <button id="deleteWallBtn" class="danger">Delete Wall</button>
    </div>

    <!-- Label editor -->
    <div id="labelEditor" style="display:none;">
      <label>Text:</label>
      <input type="text" id="editLabelText">

      <label>Size:</label><br>
      <label><input type="radio" name="labelSize" value="small"> Small</label><br>
      <label><input type="radio" name="labelSize" value="medium" checked> Medium</label><br>
      <label><input type="radio" name="labelSize" value="large"> Large</label><br><br>

      <label>Color:</label><br>
      <label><input type="radio" name="labelColor" value="black" checked> Black</label><br>
      <label><input type="radio" name="labelColor" value="gray"> Gray</label><br>
      <label><input type="radio" name="labelColor" value="blue"> Blue</label><br><br>

      <button id="applyLabelEditBtn">Apply Changes</button>
      <button id="deleteLabelBtn" class="danger">Delete Label</button>
    </div>

  </div>
</div>

<div class="hint">
  Rectangles: left-click to select, drag to move, drag small circle to rotate, [ and ] to rotate with snap.  
  Circles: left-click to select, drag to move.  
  Walls: choose "Add Wall", click start (snaps), move mouse to see preview, click end (snaps). One wall per click of the tool. Click wall or its endpoints to edit and drag.  
  Labels: choose "Add Label" and click to place text. Click a label to edit text, size, color, and drag to move.  
  Right-click and drag to pan. Mouse wheel to zoom.
</div>

<!-- jsPDF CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>
/* ===== INITIAL SETUP ===== */
const canvas = document.getElementById("layoutCanvas");
const ctx = canvas.getContext("2d");

let room = { width: 20, height: 30, units: "ft" };
let baseScale = 10;     // scale from room units to pixels (before zoom)
const padding = 30;

let items = [];   // {id, type: "rect"|"circle", name, width, depth, diameter, x, y, rotation, color}
let walls = [];   // {id, x1,y1,x2,y2, style: "interior"|"exterior"}
let labels = [];  // {id, text, x, y, size, color}
let nextItemId = 1;
let nextWallId = 1;
let nextLabelId = 1;

let selectedItemId = null;
let selectedWallId = null;
let selectedLabelId = null;

let isDragging = false;
let dragItemId = null;
let dragOffset = { x:0, y:0 };

let isRotating = false;
let rotateItemId = null;
let rotateStartAngle = 0;
let rotateStartMouseAngle = 0;

// wall drag
let wallDragMode = null; // "line" | "end1" | "end2" | null
let wallDragData = null; // { wallId, startWorld, orig }

// label drag
let labelDragId = null;
let labelDragOffset = { x: 0, y: 0 };

let isDirty = false; // track unsaved changes

// Zoom + pan
let viewScale = 1;   // additional zoom factor
let offsetX = 0;     // pan in pixels
let offsetY = 0;
let isPanning = false;
let panLastX = 0;
let panLastY = 0;

// Tool mode
let toolMode = "select"; // "select" | "wall" | "label"
let wallDraftStart = null; // first click point (world coords) for wall

// For wall preview
let wallPreviewCurrent = null; // { x, y } world coords when wallDraftStart is set

function markDirty() {
  isDirty = true;
}
function markClean() {
  isDirty = false;
}

/* Warn if leaving page with unsaved changes */
window.addEventListener("beforeunload", (e) => {
  if (!isDirty) return;
  e.preventDefault();
  e.returnValue = "";
});

/* Prevent right-click menu on canvas (we use right-click for pan) */
canvas.addEventListener("contextmenu", (e) => e.preventDefault());

/* ===== GRID STEP / SNAP ===== */
function getMinorGridStep() {
  return room.units === "m" ? 0.1 : 0.25;
}
function getMajorGridStep() {
  return room.units === "m" ? 0.5 : 1.0;
}
function snapToGridValue(v) {
  const step = getMinorGridStep();
  return Math.round(v / step) * step;
}

/**
 * Snap a point in world coords with awareness of pixel position.
 * For now, we snap to the grid only, but this is the place where
 * endpoint/intersection snapping can be layered in later.
 */
function getSnappedPoint(world, px, py, mode) {
  // mode could later be "wall" | "door" | "generic"
  return {
    x: snapToGridValue(world.x),
    y: snapToGridValue(world.y)
  };
}

/* ===== CANVAS SIZING ===== */
function resizeCanvas() {
  const rect = document.getElementById("canvasContainer").getBoundingClientRect();
  canvas.width = rect.width;
  canvas.height = rect.height;
  computeBaseScale();
  // Do not reset zoom/pan here; user may want to keep view
  draw();
}

function computeBaseScale() {
  const usableW = canvas.width - padding*2;
  const usableH = canvas.height - padding*2;
  baseScale = Math.min(usableW / room.width, usableH / room.height);
}

function effectiveScale() {
  return baseScale * viewScale;
}

function roomToCanvas(x,y){
  const s = effectiveScale();
  return {
    x: padding + offsetX + x * s,
    y: padding + offsetY + y * s
  };
}

function canvasToRoom(x,y){
  const s = effectiveScale();
  return {
    x: (x - padding - offsetX) / s,
    y: (y - padding - offsetY) / s
  };
}

/* ===== BOUNDS (not clamping anymore) ===== */
function getItemBounds(item) {
  if (item.type === "circle") {
    const r = item.diameter / 2;
    return { halfW: r, halfH: r };
  } else { // rect
    const w = item.width;
    const d = item.depth;
    const a = item.rotation || 0;
    const cos = Math.cos(a);
    const sin = Math.sin(a);
    const halfW = 0.5 * (Math.abs(w * cos) + Math.abs(d * sin));
    const halfH = 0.5 * (Math.abs(w * sin) + Math.abs(d * cos));
    return { halfW, halfH };
  }
}

/* ===== ITEM COLORS ===== */
function getItemFillColor(color) {
  switch (color) {
    case "green":  return "#d6f5d6";
    case "orange": return "#ffe0b3";
    case "gray":   return "#e0e0e0";
    case "blue":
    default:       return "#d5e8ff";
  }
}

function getItemStrokeColor(color) {
  switch (color) {
    case "green":  return "#3c7a3c";
    case "orange": return "#b36b00";
    case "gray":   return "#555555";
    case "blue":
    default:       return "#555555";
  }
}

/* ===== LABEL FONT HELPER ===== */
function getLabelFont(label) {
  switch (label.size) {
    case "small": return "12px system-ui";
    case "large": return "20px system-ui";
    case "medium":
    default: return "14px system-ui";
  }
}

/* ===== DRAWING ===== */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawRoom(ctx, roomToCanvas, effectiveScale());
  drawGrid(ctx, roomToCanvas);
  drawWalls(ctx, roomToCanvas);
  drawItems(ctx, roomToCanvas);
  drawLabels(ctx, roomToCanvas);
  drawDimensions(ctx, roomToCanvas);
  drawWallPreview(ctx, roomToCanvas);
}

function drawRoom(ctxLocal, roomToCanvasFn, effScale){
  const tl = roomToCanvasFn(0,0);
  const br = roomToCanvasFn(room.width,room.height);
  ctxLocal.strokeStyle="#000";
  ctxLocal.lineWidth=2;
  ctxLocal.strokeRect(tl.x,tl.y,br.x-tl.x,br.y-tl.y);
}

function drawGrid(ctxLocal, roomToCanvasFn){
  const major = getMajorGridStep();
  const minor = getMinorGridStep();
  ctxLocal.save();

  ctxLocal.strokeStyle="#eee";
  ctxLocal.beginPath();
  for(let x=0; x<=room.width+1e-6; x+=minor){
    const p1=roomToCanvasFn(x,0), p2=roomToCanvasFn(x,room.height);
    ctxLocal.moveTo(p1.x,p1.y); ctxLocal.lineTo(p2.x,p2.y);
  }
  for(let y=0; y<=room.height+1e-6; y+=minor){
    const p1=roomToCanvasFn(0,y), p2=roomToCanvasFn(room.width,y);
    ctxLocal.moveTo(p1.x,p1.y); ctxLocal.lineTo(p2.x,p2.y);
  }
  ctxLocal.stroke();

  ctxLocal.strokeStyle="#ccc";
  ctxLocal.beginPath();
  for(let x=0; x<=room.width+1e-6; x+=major){
    const p1=roomToCanvasFn(x,0), p2=roomToCanvasFn(x,room.height);
    ctxLocal.moveTo(p1.x,p1.y); ctxLocal.lineTo(p2.x,p2.y);
  }
  for(let y=0; y<=room.height+1e-6; y+=major){
    const p1=roomToCanvasFn(0,y), p2=roomToCanvasFn(room.width,y);
    ctxLocal.moveTo(p1.x,p1.y); ctxLocal.lineTo(p2.x,p2.y);
  }
  ctxLocal.stroke();

  ctxLocal.restore();
}

/* Walls */
function drawWalls(ctxLocal, roomToCanvasFn) {
  walls.forEach(wall => {
    const p1 = roomToCanvasFn(wall.x1, wall.y1);
    const p2 = roomToCanvasFn(wall.x2, wall.y2);

    let isSelected = (wall.id === selectedWallId);

    // Scale wall thickness with zoom, but gently
    const scaleFactor = Math.sqrt(viewScale);

    // Base pixel thickness
    let baseInterior = 2;
    let baseExterior = 4;

    let width;
    if (wall.style === "exterior") {
      ctxLocal.strokeStyle = isSelected ? "#ff0000" : "#000000";
      width = baseExterior * scaleFactor;
      if (isSelected) width *= 1.3;
    } else {
      ctxLocal.strokeStyle = isSelected ? "#ff0000" : "#666666";
      width = baseInterior * scaleFactor;
      if (isSelected) width *= 1.3;
    }

    ctxLocal.lineWidth = width;

    ctxLocal.beginPath();
    ctxLocal.moveTo(p1.x, p1.y);
    ctxLocal.lineTo(p2.x, p2.y);
    ctxLocal.stroke();

    // Draw endpoint handles if selected
    if (isSelected) {
      ctxLocal.fillStyle = "#ffffff";
      ctxLocal.strokeStyle = "#ff0000";
      ctxLocal.lineWidth = 2;
      [p1, p2].forEach(pt => {
        ctxLocal.beginPath();
        ctxLocal.arc(pt.x, pt.y, 6, 0, Math.PI*2);
        ctxLocal.fill();
        ctxLocal.stroke();
      });
    }
  });
}

/* Items */
function drawItems(ctxLocal, roomToCanvasFn){
  items.forEach(item => drawItem(ctxLocal, roomToCanvasFn, item));
}

function drawItem(ctxLocal, roomToCanvasFn, item){
  if (item.type === "circle") {
    drawCircleItem(ctxLocal, roomToCanvasFn, item);
  } else {
    drawRectItem(ctxLocal, roomToCanvasFn, item);
  }
}

function drawRectItem(ctxLocal, roomToCanvasFn, item){
  const c = roomToCanvasFn(item.x,item.y);
  const s = effectiveScale();
  const w = item.width * s;
  const h = item.depth * s;

  const fillCol = getItemFillColor(item.color);
  const strokeCol = getItemStrokeColor(item.color);

  ctxLocal.save();
  ctxLocal.translate(c.x,c.y);
  ctxLocal.rotate(item.rotation || 0);

  ctxLocal.fillStyle = fillCol;
  ctxLocal.strokeStyle = (item.id===selectedItemId ? "#06c" : strokeCol);
  ctxLocal.lineWidth = (item.id===selectedItemId ? 2 : 1.2);

  ctxLocal.fillRect(-w/2,-h/2,w,h);
  ctxLocal.strokeRect(-w/2,-h/2,w,h);

  ctxLocal.save();
  ctxLocal.rotate(-(item.rotation || 0));
  ctxLocal.fillStyle="#000";
  ctxLocal.font="13px system-ui";
  ctxLocal.textAlign="center";
  ctxLocal.textBaseline="middle";
  ctxLocal.fillText(item.name,0,0);
  ctxLocal.restore();

  ctxLocal.restore();

  if(item.id===selectedItemId) drawRotateHandle(ctxLocal, roomToCanvasFn, item);
}

function drawCircleItem(ctxLocal, roomToCanvasFn, item){
  const c = roomToCanvasFn(item.x,item.y);
  const s = effectiveScale();
  const r = (item.diameter/2) * s;

  const fillCol = getItemFillColor(item.color);
  const strokeCol = getItemStrokeColor(item.color);

  ctxLocal.save();
  ctxLocal.beginPath();
  ctxLocal.arc(c.x, c.y, r, 0, Math.PI*2);
  ctxLocal.fillStyle = fillCol;
  ctxLocal.fill();
  ctxLocal.strokeStyle = (item.id===selectedItemId ? "#06c" : strokeCol);
  ctxLocal.lineWidth = (item.id===selectedItemId ? 2 : 1.2);
  ctxLocal.stroke();

  ctxLocal.fillStyle="#000";
  ctxLocal.font="13px system-ui";
  ctxLocal.textAlign="center";
  ctxLocal.textBaseline="middle";
  ctxLocal.fillText(item.name, c.x, c.y);
  ctxLocal.restore();
}

/* Labels */
function drawLabels(ctxLocal, roomToCanvasFn) {
  ctxLocal.save();
  ctxLocal.textAlign = "center";
  ctxLocal.textBaseline = "middle";

  labels.forEach(label => {
    const p = roomToCanvasFn(label.x, label.y);
    ctxLocal.font = getLabelFont(label);
    ctxLocal.fillStyle = label.color || "#444";
    ctxLocal.fillText(label.text, p.x, p.y);

    if (label.id === selectedLabelId) {
      const paddingPx = 4;
      const textWidth = ctxLocal.measureText(label.text).width;
      const boxW = textWidth + paddingPx*2;
      const boxH = 20;
      ctxLocal.strokeStyle = "#ff0000";
      ctxLocal.lineWidth = 1;
      ctxLocal.strokeRect(p.x - boxW/2, p.y - boxH/2, boxW, boxH);
    }
  });

  ctxLocal.restore();
}

/* Dimensions */
function drawDimensions(ctxLocal, roomToCanvasFn) {
  ctxLocal.save();
  ctxLocal.strokeStyle = "#999";
  ctxLocal.fillStyle = "#555";
  ctxLocal.lineWidth = 1;
  ctxLocal.font = "12px system-ui";
  ctxLocal.textAlign = "center";
  ctxLocal.textBaseline = "middle";

  const tl = roomToCanvasFn(0,0);
  const tr = roomToCanvasFn(room.width,0);
  const bl = roomToCanvasFn(0,room.height);

  // Top dimension line (width)
  const yOff = tl.y - 20;
  ctxLocal.beginPath();
  ctxLocal.moveTo(tl.x, yOff);
  ctxLocal.lineTo(tr.x, yOff);
  ctxLocal.stroke();

  // Arrows
  const arrowSize = 5;
  ctxLocal.beginPath();
  ctxLocal.moveTo(tl.x, yOff);
  ctxLocal.lineTo(tl.x + arrowSize, yOff - arrowSize);
  ctxLocal.moveTo(tl.x, yOff);
  ctxLocal.lineTo(tl.x + arrowSize, yOff + arrowSize);

  ctxLocal.moveTo(tr.x, yOff);
  ctxLocal.lineTo(tr.x - arrowSize, yOff - arrowSize);
  ctxLocal.moveTo(tr.x, yOff);
  ctxLocal.lineTo(tr.x - arrowSize, yOff + arrowSize);
  ctxLocal.stroke();

  const widthText = room.width.toFixed(2) + " " + room.units;
  ctxLocal.fillText(widthText, (tl.x + tr.x) / 2, yOff - 10);

  // Left dimension line (height)
  const xOff = tl.x - 20;
  ctxLocal.beginPath();
  ctxLocal.moveTo(xOff, tl.y);
  ctxLocal.lineTo(xOff, bl.y);
  ctxLocal.stroke();

  ctxLocal.beginPath();
  ctxLocal.moveTo(xOff, tl.y);
  ctxLocal.lineTo(xOff - arrowSize, tl.y + arrowSize);
  ctxLocal.moveTo(xOff, tl.y);
  ctxLocal.lineTo(xOff + arrowSize, tl.y + arrowSize);

  ctxLocal.moveTo(xOff, bl.y);
  ctxLocal.lineTo(xOff - arrowSize, bl.y - arrowSize);
  ctxLocal.moveTo(xOff, bl.y);
  ctxLocal.lineTo(xOff + arrowSize, bl.y - arrowSize);
  ctxLocal.stroke();

  const heightText = room.height.toFixed(2) + " " + room.units;
  ctxLocal.save();
  ctxLocal.translate(xOff - 15, (tl.y + bl.y) / 2);
  ctxLocal.rotate(-Math.PI/2);
  ctxLocal.fillText(heightText, 0, 0);
  ctxLocal.restore();

  ctxLocal.restore();
}

/* Wall preview (rubber-band) */
function drawWallPreview(ctxLocal, roomToCanvasFn) {
  if (!wallDraftStart || !wallPreviewCurrent) return;

  const p1 = roomToCanvasFn(wallDraftStart.x, wallDraftStart.y);
  const p2 = roomToCanvasFn(wallPreviewCurrent.x, wallPreviewCurrent.y);

  ctxLocal.save();
  ctxLocal.strokeStyle = "rgba(0,0,0,0.5)";
  ctxLocal.setLineDash([5,4]);
  ctxLocal.lineWidth = 1;
  ctxLocal.beginPath();
  ctxLocal.moveTo(p1.x, p1.y);
  ctxLocal.lineTo(p2.x, p2.y);
  ctxLocal.stroke();
  ctxLocal.setLineDash([]);
  ctxLocal.restore();
}

/* Rotate handle */
function drawRotateHandle(ctxLocal, roomToCanvasFn, item){
  if (item.type !== "rect") return; // circles donâ€™t rotate

  const c=roomToCanvasFn(item.x,item.y);
  const s = effectiveScale();
  const h=item.depth * s;
  const half=h/2, offset=20;
  const L=half+offset;
  const a = item.rotation || 0;

  const hx=c.x + L*Math.sin(a);
  const hy=c.y - L*Math.cos(a);

  ctxLocal.save();
  ctxLocal.fillStyle="#fff";
  ctxLocal.strokeStyle="#06c";
  ctxLocal.lineWidth=2;

  ctxLocal.beginPath();
  ctxLocal.arc(hx,hy,7,0,Math.PI*2);
  ctxLocal.fill();
  ctxLocal.stroke();

  ctxLocal.beginPath();
  ctxLocal.moveTo(c.x,c.y);
  ctxLocal.lineTo(hx,hy);
  ctxLocal.stroke();

  ctxLocal.restore();
}

/* ===== HIT TEST (ITEMS ONLY) ===== */
function getHit(px,py){
  for(let i=items.length-1;i>=0;i--){
    const item=items[i];
    if (item.type === "rect" && isRotateHandle(px,py,item)) {
      return {item,mode:"rotate"};
    }
    if (isInsideItem(px,py,item)) {
      return {item,mode:"move"};
    }
  }
  return null;
}

function isInsideItem(px,py,item){
  if (item.type === "circle") {
    const c = roomToCanvas(item.x,item.y);
    const s = effectiveScale();
    const r = (item.diameter/2) * s;
    return Math.hypot(px - c.x, py - c.y) <= r;
  } else {
    const c = roomToCanvas(item.x,item.y);
    let dx=px-c.x, dy=py-c.y;
    const a = item.rotation || 0;
    const cos=Math.cos(-a), sin=Math.sin(-a);
    let x=dx*cos - dy*sin;
    let y=dx*sin + dy*cos;
    const s = effectiveScale();
    const hw=item.width*s/2, hh=item.depth*s/2;
    return (x>=-hw && x<=hw && y>=-hh && y<=hh);
  }
}

function isRotateHandle(px,py,item){
  if (item.type !== "rect") return false;
  const c=roomToCanvas(item.x,item.y);
  const s = effectiveScale();
  const h=item.depth*s;
  const half=h/2, offset=20;
  const L=half+offset;
  const a = item.rotation || 0;

  const hx=c.x + L*Math.sin(a);
  const hy=c.y - L*Math.cos(a);

  return Math.hypot(px-hx,py-hy)<=10;
}

/* ===== WALL HIT TEST ===== */
function hitTestWall(px, py) {
  const endRadius = 10;      // px for endpoint
  const lineThreshold = 6;   // px for line

  for (let i = walls.length - 1; i >= 0; i--) {
    const wall = walls[i];
    const p1 = roomToCanvas(wall.x1, wall.y1);
    const p2 = roomToCanvas(wall.x2, wall.y2);

    const d1 = Math.hypot(px - p1.x, py - p1.y);
    if (d1 <= endRadius) {
      return { wall, mode: "end1" };
    }
    const d2 = Math.hypot(px - p2.x, py - p2.y);
    if (d2 <= endRadius) {
      return { wall, mode: "end2" };
    }

    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const len2 = dx*dx + dy*dy;
    if (len2 === 0) continue;
    let t = ((px - p1.x)*dx + (py - p1.y)*dy) / len2;
    t = Math.max(0, Math.min(1, t));
    const projX = p1.x + t*dx;
    const projY = p1.y + t*dy;
    const distLine = Math.hypot(px - projX, py - projY);
    if (distLine <= lineThreshold) {
      return { wall, mode: "line" };
    }
  }
  return null;
}

/* ===== LABEL HIT TEST ===== */
function hitTestLabel(px, py) {
  const radius = 10;
  for (let i = labels.length - 1; i >= 0; i--) {
    const label = labels[i];
    const p = roomToCanvas(label.x, label.y);
    if (Math.hypot(px - p.x, py - p.y) <= radius) {
      return label;
    }
  }
  return null;
}

/* ===== TOOL BUTTONS ===== */
const toolSelectBtn = document.getElementById("toolSelectBtn");
const toolWallBtn = document.getElementById("toolWallBtn");
const toolLabelBtn = document.getElementById("toolLabelBtn");

function setToolMode(mode) {
  toolMode = mode;
  wallDraftStart = null;
  wallPreviewCurrent = null;
  toolSelectBtn.classList.remove("active");
  toolWallBtn.classList.remove("active");
  toolLabelBtn.classList.remove("active");
  if (mode === "select") toolSelectBtn.classList.add("active");
  if (mode === "wall")   toolWallBtn.classList.add("active");
  if (mode === "label")  toolLabelBtn.classList.add("active");
}

toolSelectBtn.addEventListener("click", () => setToolMode("select"));
toolWallBtn.addEventListener("click", () => setToolMode("wall"));
toolLabelBtn.addEventListener("click", () => setToolMode("label"));

/* ===== MOUSE EVENTS ===== */
canvas.addEventListener("mousedown", e=>{
  const rect=canvas.getBoundingClientRect();
  const px=e.clientX-rect.left, py=e.clientY-rect.top;

  // Right-click: start panning
  if (e.button === 2) {
    isPanning = true;
    panLastX = e.clientX;
    panLastY = e.clientY;
    return;
  }

  // Left button only
  if (e.button !== 0) return;

  const world = canvasToRoom(px, py);

  // TOOL: WALL (single-use, with preview)
  if (toolMode === "wall") {
    const snapped = getSnappedPoint(world, px, py, "wall");

    if (!wallDraftStart) {
      wallDraftStart = snapped;
      wallPreviewCurrent = snapped;
    } else {
      const wallTypeInput = document.querySelector('input[name="wallType"]:checked');
      const style = wallTypeInput ? wallTypeInput.value : "interior";

      walls.push({
        id: nextWallId++,
        x1: wallDraftStart.x,
        y1: wallDraftStart.y,
        x2: snapped.x,
        y2: snapped.y,
        style
      });

      wallDraftStart = null;
      wallPreviewCurrent = null;
      markDirty();
      setToolMode("select");
      draw();
    }
    return;
  }

  // TOOL: LABEL (single-use)
  if (toolMode === "label") {
    const text = prompt("Label text:", "");
    if (text && text.trim() !== "") {
      labels.push({
        id: nextLabelId++,
        text: text.trim(),
        x: world.x,
        y: world.y,
        size: "medium",
        color: "black"
      });
      markDirty();
      draw();
    }
    setToolMode("select");
    return;
  }

  // TOOL: SELECT
  const hit=getHit(px,py);
  if(hit){
    selectedItemId=hit.item.id;
    selectedWallId=null;
    selectedLabelId=null;
    updateSidebar();

    if(hit.mode==="move"){
      isDragging=true; dragItemId=hit.item.id;
      const rp=world;
      dragOffset.x=rp.x-hit.item.x;
      dragOffset.y=rp.y-hit.item.y;
    }

    if(hit.mode==="rotate"){
      isRotating=true; rotateItemId=hit.item.id;
      const c=roomToCanvas(hit.item.x,hit.item.y);
      rotateStartMouseAngle=Math.atan2(py-c.y, px-c.x);
      rotateStartAngle=hit.item.rotation || 0;
    }

    draw();
    return;
  }

  const wallHit = hitTestWall(px, py);
  if (wallHit) {
    selectedWallId = wallHit.wall.id;
    selectedItemId = null;
    selectedLabelId = null;
    updateSidebar();
    wallDragMode = wallHit.mode;
    wallDragData = {
      wallId: wallHit.wall.id,
      startWorld: world,
      orig: {
        x1: wallHit.wall.x1,
        y1: wallHit.wall.y1,
        x2: wallHit.wall.x2,
        y2: wallHit.wall.y2
      }
    };
    draw();
    return;
  }

  const labelHit = hitTestLabel(px, py);
  if (labelHit) {
    selectedLabelId = labelHit.id;
    selectedItemId = null;
    selectedWallId = null;
    updateSidebar();
    labelDragId = labelHit.id;
    labelDragOffset.x = world.x - labelHit.x;
    labelDragOffset.y = world.y - labelHit.y;
    draw();
    return;
  }

  selectedItemId=null;
  selectedWallId=null;
  selectedLabelId=null;
  wallDragMode = null;
  wallDragData = null;
  labelDragId = null;
  updateSidebar();
  draw();
});

canvas.addEventListener("mousemove", e=>{
  const rect=canvas.getBoundingClientRect();
  const px=e.clientX-rect.left, py=e.clientY-rect.top;
  const world = canvasToRoom(px, py);

  if (isPanning) {
    const dx = e.clientX - panLastX;
    const dy = e.clientY - panLastY;
    panLastX = e.clientX;
    panLastY = e.clientY;
    offsetX += dx;
    offsetY += dy;
    draw();
    return;
  }

  if (toolMode === "wall" && wallDraftStart) {
    const snapped = getSnappedPoint(world, px, py, "wall");
    wallPreviewCurrent = snapped;
    draw();
    return;
  }

  if(isDragging && dragItemId){
    const item=items.find(i=>i.id===dragItemId);
    item.x=world.x-dragOffset.x;
    item.y=world.y-dragOffset.y;
    markDirty();
    draw();
    updateSidebar();
  }

  if(isRotating && rotateItemId){
    const item=items.find(i=>i.id===rotateItemId);
    if (item.type !== "rect") return;

    const c=roomToCanvas(item.x,item.y);
    const ang=Math.atan2(py-c.y, px-c.x);
    item.rotation=rotateStartAngle + (ang-rotateStartMouseAngle);
    snapRotation(item);
    markDirty();

    draw();
    updateSidebar();
  }

  if (wallDragMode && wallDragData) {
    const wall = walls.find(w => w.id === wallDragData.wallId);
    if (!wall) return;

    if (wallDragMode === "line") {
      const dx = world.x - wallDragData.startWorld.x;
      const dy = world.y - wallDragData.startWorld.y;

      wall.x1 = wallDragData.orig.x1 + dx;
      wall.y1 = wallDragData.orig.y1 + dy;
      wall.x2 = wallDragData.orig.x2 + dx;
      wall.y2 = wallDragData.orig.y2 + dy;
    } else if (wallDragMode === "end1") {
      wall.x1 = world.x;
      wall.y1 = world.y;
    } else if (wallDragMode === "end2") {
      wall.x2 = world.x;
      wall.y2 = world.y;
    }

    markDirty();
    draw();
  }

  if (labelDragId) {
    const label = labels.find(l => l.id === labelDragId);
    if (label) {
      label.x = world.x - labelDragOffset.x;
      label.y = world.y - labelDragOffset.y;
      markDirty();
      draw();
    }
  }
});

window.addEventListener("mouseup", e=>{
  isDragging=false;
  dragItemId=null;
  isRotating=false;
  rotateItemId=null;
  if (e.button === 2) {
    isPanning = false;
  }
  wallDragMode = null;
  wallDragData = null;
  labelDragId = null;
});

/* ===== MOUSE WHEEL ZOOM ===== */
canvas.addEventListener("wheel", (e)=>{
  e.preventDefault();

  const rect = canvas.getBoundingClientRect();
  const px = e.clientX - rect.left;
  const py = e.clientY - rect.top;

  const world = canvasToRoom(px, py);

  const factor = (e.deltaY < 0 ? 1.05 : 0.95);
  let newViewScale = viewScale * factor;
  const minViewScale = 1;
  const maxViewScale = 6;
  newViewScale = Math.max(minViewScale, Math.min(maxViewScale, newViewScale));
  viewScale = newViewScale;

  const s = effectiveScale();
  offsetX = px - padding - world.x * s;
  offsetY = py - padding - world.y * s;

  draw();
}, { passive: false });

/* ===== SNAP ROTATION ===== */
function snapRotation(item){
  const targets=[0,90,180,270].map(d=>d*Math.PI/180);
  let a=(item.rotation || 0)%(2*Math.PI);
  if(a<0)a+=2*Math.PI;

  let best=a, min=999;
  for(let t of targets){
    let diff=Math.abs(a-t);
    diff=Math.min(diff,2*Math.PI-diff);
    if(diff<min){min=diff; best=t;}
  }

  if(min < 5*Math.PI/180) item.rotation=best;
}

/* ===== KEYBOARD ROTATION ===== */
document.addEventListener("keydown", e=>{
  if(!selectedItemId)return;
  const item=items.find(i=>i.id===selectedItemId);
  if (!item || item.type !== "rect") return;

  const step=5*Math.PI/180;
  if(e.key==="[") item.rotation = (item.rotation || 0) - step;
  if(e.key==="]") item.rotation = (item.rotation || 0) + step;

  snapRotation(item);
  markDirty();
  draw();
  updateSidebar();
});

/* ===== ADD RECTANGLE ===== */
document.getElementById("addItemBtn").addEventListener("click", ()=>{
  const name=document.getElementById("itemName").value || ("Rect "+nextItemId);
  const w=parseFloat(document.getElementById("itemWidth").value);
  const d=parseFloat(document.getElementById("itemDepth").value);
  if(!(w>0 && d>0)) return alert("Invalid rectangle size.");

  const item={
    id:nextItemId++,
    type:"rect",
    name,
    width:w,
    depth:d,
    x:room.width/2,
    y:room.height/2,
    rotation:0,
    color:"blue"
  };
  items.push(item);
  selectedItemId=item.id;
  selectedWallId=null;
  selectedLabelId=null;
  markDirty();

  draw(); updateSidebar();
});

/* ===== ADD CIRCLE ===== */
document.getElementById("addCircleBtn").addEventListener("click", ()=>{
  const name=document.getElementById("circleName").value || ("Circle "+nextItemId);
  const dia=parseFloat(document.getElementById("circleDiameter").value);
  if(!(dia>0)) return alert("Invalid circle diameter.");

  const item={
    id:nextItemId++,
    type:"circle",
    name,
    diameter:dia,
    x:room.width/2,
    y:room.height/2,
    rotation:0,
    color:"blue"
  };
  items.push(item);
  selectedItemId=item.id;
  selectedWallId=null;
  selectedLabelId=null;
  markDirty();

  draw(); updateSidebar();
});

/* ===== SIDEBAR UPDATER ===== */
function updateSidebar() {
  const sidebarTitle = document.getElementById("sidebarTitle");
  const noSel   = document.getElementById("noSelection");
  const itemEd  = document.getElementById("itemEditor");
  const wallEd  = document.getElementById("wallEditor");
  const labelEd = document.getElementById("labelEditor");
  const rectFields = document.getElementById("rectFields");
  const circleFields = document.getElementById("circleFields");

  noSel.style.display   = "block";
  itemEd.style.display  = "none";
  wallEd.style.display  = "none";
  labelEd.style.display = "none";
  sidebarTitle.textContent = "Nothing Selected";

  if (selectedItemId) {
    const item = items.find(i => i.id === selectedItemId);
    if (!item) return;

    noSel.style.display = "none";
    itemEd.style.display = "block";
    sidebarTitle.textContent = "Item Details";

    document.getElementById("editName").value = item.name;

    if (item.type === "rect") {
      rectFields.style.display = "block";
      circleFields.style.display = "none";
      document.getElementById("editWidth").value = item.width;
      document.getElementById("editDepth").value = item.depth;
      document.getElementById("editRotation").value = ((item.rotation||0)*180/Math.PI).toFixed(2);
    } else {
      rectFields.style.display = "none";
      circleFields.style.display = "block";
      document.getElementById("editDiameter").value = item.diameter;
    }

    const radios = document.querySelectorAll('input[name="editColor"]');
    radios.forEach(r => r.checked = (r.value === item.color));

    return;
  }

  if (selectedWallId) {
    const wall = walls.find(w => w.id === selectedWallId);
    if (!wall) return;

    noSel.style.display = "none";
    wallEd.style.display = "block";
    sidebarTitle.textContent = "Wall Details";

    const typeRadios = document.querySelectorAll('input[name="wallEditType"]');
    typeRadios.forEach(r => r.checked = (r.value === wall.style));

    return;
  }

  if (selectedLabelId) {
    const label = labels.find(l => l.id === selectedLabelId);
    if (!label) return;

    noSel.style.display = "none";
    labelEd.style.display = "block";
    sidebarTitle.textContent = "Label Details";

    document.getElementById("editLabelText").value = label.text;

    document.querySelectorAll("input[name='labelSize']").forEach(r => {
      r.checked = (r.value === (label.size || "medium"));
    });

    document.querySelectorAll("input[name='labelColor']").forEach(r => {
      r.checked = (r.value === (label.color || "black"));
    });

    return;
  }
}

/* ===== ITEM EDIT APPLY / DELETE ===== */
document.getElementById("applyEditBtn").addEventListener("click", ()=>{
  const item=items.find(i=>i.id===selectedItemId);
  if(!item)return;

  item.name=document.getElementById("editName").value;

  if (item.type === "rect") {
    let w=parseFloat(document.getElementById("editWidth").value);
    let d=parseFloat(document.getElementById("editDepth").value);
    if(!(w>0)) w=item.width;
    if(!(d>0)) d=item.depth;
    item.width=w;
    item.depth=d;

    let rDeg=parseFloat(document.getElementById("editRotation").value);
    if(!isNaN(rDeg)){
      item.rotation=rDeg*Math.PI/180;
      snapRotation(item);
    }
  } else {
    let dia=parseFloat(document.getElementById("editDiameter").value);
    if(!(dia>0)) dia=item.diameter;
    item.diameter=dia;
  }

  const colorInput = document.querySelector('input[name="editColor"]:checked');
  if (colorInput) {
    item.color = colorInput.value;
  }

  markDirty();
  draw(); 
  updateSidebar();
});

document.getElementById("deleteItemBtn").addEventListener("click", ()=>{
  items=items.filter(i=>i.id!==selectedItemId);
  selectedItemId=null;
  markDirty();
  draw(); updateSidebar();
});

/* ===== WALL EDIT APPLY / DELETE ===== */
document.getElementById("applyWallEditBtn").addEventListener("click", ()=>{
  const wall = walls.find(w => w.id === selectedWallId);
  if (!wall) return;

  const r = document.querySelector('input[name="wallEditType"]:checked');
  if (r) wall.style = r.value || "interior";

  markDirty();
  draw();
  updateSidebar();
});

document.getElementById("deleteWallBtn").addEventListener("click", ()=>{
  walls = walls.filter(w => w.id !== selectedWallId);
  selectedWallId = null;
  markDirty();
  draw();
  updateSidebar();
});

/* ===== LABEL EDIT APPLY / DELETE ===== */
document.getElementById("applyLabelEditBtn").addEventListener("click", ()=>{
  const label = labels.find(l => l.id === selectedLabelId);
  if (!label) return;

  label.text = document.getElementById("editLabelText").value;

  const s = document.querySelector("input[name='labelSize']:checked");
  if (s) label.size = s.value;

  const c = document.querySelector("input[name='labelColor']:checked");
  if (c) label.color = c.value;

  markDirty();
  draw();
  updateSidebar();
});

document.getElementById("deleteLabelBtn").addEventListener("click", ()=>{
  labels = labels.filter(l => l.id !== selectedLabelId);
  selectedLabelId = null;
  markDirty();
  draw();
  updateSidebar();
});

/* ===== ROOM APPLY ===== */
document.getElementById("applyRoomBtn").addEventListener("click", ()=>{
  const w=parseFloat(document.getElementById("roomWidth").value);
  const h=parseFloat(document.getElementById("roomHeight").value);
  if(!(w>0 && h>0)) return alert("Invalid room dimensions.");

  room.width=w;
  room.height=h;
  room.units=document.getElementById("roomUnits").value;

  computeBaseScale();
  markDirty();
  draw();
});

/* ===== DOWNLOAD / UPLOAD JSON ===== */
document.getElementById("downloadBtn").addEventListener("click", ()=>{
  const blob=new Blob(
    [JSON.stringify({room,items,walls,labels,nextItemId,nextWallId,nextLabelId},null,2)],
    {type:"application/json"}
  );
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url; a.download="shop_layout.json"; a.click();
  URL.revokeObjectURL(url);
  markClean();
});

const fileInput = document.getElementById("fileInput");

document.getElementById("uploadBtn").addEventListener("click", ()=>fileInput.click());

fileInput.addEventListener("change", e=>{
  const file=e.target.files[0];
  if(!file)return;

  const reader=new FileReader();
  reader.onload=function(evt){
    const obj=JSON.parse(evt.target.result);
    room=obj.room;
    items=obj.items || [];
    walls=obj.walls || [];
    labels=obj.labels || [];
    nextItemId=obj.nextItemId || 1;
    nextWallId=obj.nextWallId || 1;
    nextLabelId=obj.nextLabelId || 1;

    items.forEach(it=>{
      if (!it.type) it.type="rect";
      if (!it.color) it.color="blue";
      if (it.type==="circle" && typeof it.diameter!=="number") {
        it.type="rect";
      }
      if (it.type==="rect" && typeof it.rotation!=="number") {
        it.rotation=0;
      }
    });

    labels.forEach(l => {
      if (!l.size) l.size = "medium";
      if (!l.color) l.color = "black";
    });

    computeBaseScale();
    selectedItemId=null;
    selectedWallId=null;
    selectedLabelId=null;
    markClean();
    draw(); 
    updateSidebar();
  };
  reader.readAsText(file);
  fileInput.value="";
});

/* ===== SAVE PDF (FULL ROOM, NO SELECTIONS) ===== */
document.getElementById("pdfBtn").addEventListener("click", ()=>{
  const { jsPDF } = window.jspdf;
  const headerText = document.getElementById("pdfHeader").value || "Shop Layout";

  const pdfPageSize = "letter"; // or "a4"
  const pdf = new jsPDF({
    orientation: room.width >= room.height ? "landscape" : "portrait",
    unit: "pt",
    format: pdfPageSize
  });

  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();

  const headerSpace = 40;
  const availableWidth = pageWidth - 40;
  const availableHeight = pageHeight - headerSpace - 40;

  const aspectRoom = room.width / room.height;
  const aspectPage = availableWidth / availableHeight;

  let drawWidth, drawHeight;
  if (aspectRoom > aspectPage) {
    drawWidth = availableWidth;
    drawHeight = drawWidth / aspectRoom;
  } else {
    drawHeight = availableHeight;
    drawWidth = drawHeight * aspectRoom;
  }

  const offCanvas = document.createElement("canvas");
  offCanvas.width = Math.round(drawWidth);
  offCanvas.height = Math.round(drawHeight);
  const offCtx = offCanvas.getContext("2d");

  const localPadding = 20;
  const s = Math.min(
    (offCanvas.width - 2*localPadding) / room.width,
    (offCanvas.height - 2*localPadding) / room.height
  );

  function roomToCanvasPdf(x, y) {
    return {
      x: localPadding + x * s,
      y: localPadding + y * s
    };
  }

  offCtx.fillStyle = "#ffffff";
  offCtx.fillRect(0,0,offCanvas.width,offCanvas.height);

  drawRoom(offCtx, roomToCanvasPdf, s);
  drawGrid(offCtx, roomToCanvasPdf);
  drawWalls(offCtx, roomToCanvasPdf);

  offCtx.save();
  const tl = roomToCanvasPdf(0,0);
  const br = roomToCanvasPdf(room.width, room.height);
  offCtx.beginPath();
  offCtx.rect(tl.x, tl.y, br.x - tl.x, br.y - tl.y);
  offCtx.clip();

  drawItems(offCtx, roomToCanvasPdf);
  drawLabels(offCtx, roomToCanvasPdf);

  offCtx.restore();

  drawDimensions(offCtx, roomToCanvasPdf);

  const dataUrl = offCanvas.toDataURL("image/png");

  pdf.setFontSize(14);
  const textWidth = pdf.getTextWidth(headerText);
  const textX = (pageWidth - textWidth) / 2;
  const textY = 24;
  pdf.text(headerText, textX, textY);

  const imageX = (pageWidth - drawWidth) / 2;
  const imageY = headerSpace;
  pdf.addImage(dataUrl, "PNG", imageX, imageY, drawWidth, drawHeight);

  pdf.save("shop_layout.pdf");
});

/* ===== INIT ===== */
window.addEventListener("resize", resizeCanvas);
resizeCanvas();
draw();
markClean();
updateSidebar();
</script>

</body>
</html>
