<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Shop Layout Planner</title>
<style>
  body {
    font-family: system-ui, sans-serif;
    margin: 0;
    padding: 0;
    height: 100vh;
    display: flex;
    flex-direction: column;
    background: #f5f5f5;
  }

  header {
    padding: 8px 12px;
    background: #333;
    color: #fff;
    font-size: 18px;
  }

  /* Top controls container */
  .controls {
    display: flex;
    flex-direction: column;
    gap: 6px;
    padding: 10px 12px;
    background: #fafafa;
    border-bottom: 1px solid #ddd;
  }

  .controls-row {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 12px;
  }

  .row-left {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    align-items: center;
  }

  .row-right {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 6px;
    justify-content: flex-start;
    text-align: left;
    align-items: center;
  }

  button, input, select {
    border-radius: 4px;
    border: 1px solid #888;
    padding: 4px 6px;
    font-size: 14px;
  }
  button:hover { background: #eee; }

  button.active {
    background: #ddd;
    border-color: #555;
  }

  /* Layout: canvas left, sidebar right */
  #main {
    flex: 1;
    display: flex;
    flex-direction: row;
    overflow: hidden;
  }

  #canvasContainer {
    flex: 1;
    min-width: 300px;
    border-right: 1px solid #ccc;
    background: #fff;
    display: flex;
    position: relative;
  }

  #layoutCanvas {
    flex: 1;
    display: block;
    width: 100%;
    height: 100%;
    outline: none;
  }

  /* Sidebar */
  #sidebar {
    width: 260px;
    flex-shrink: 0;
    background: #f9f9f9;
    border-left: 1px solid #ccc;
    padding: 12px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  #sidebar h3 {
    font-size: 16px;
    margin: 0 0 6px 0;
  }

  #sidebar input[type="text"],
  #sidebar input[type="number"] {
    width: 100%;
    padding: 4px;
    margin-bottom: 6px;
    font-size: 13px;
  }

  #sidebar button {
    width: 100%;
    padding: 6px;
    margin-top: 4px;
    font-size: 13px;
  }

  #sidebar .danger {
    border-color: #b00;
    color: #b00;
  }

  .hint {
    padding: 6px 10px;
    font-size: 12px;
    color: #444;
    border-top: 1px solid #ddd;
    background: #fafafa;
  }

  @media print {
    header, .controls, #sidebar, .hint {
      display: none !important;
    }
    #canvasContainer {
      border: none;
    }
    #layoutCanvas {
      width: auto !important;
      height: auto !important;
    }
  }
</style>
</head>
<body>

<header>Shop Layout Planner</header>

<!-- Controls -->
<div class="controls">
  <!-- Row 1: Room (left) / Rect (right) -->
  <div class="controls-row">
    <div class="row-left">
      <label>Room W:</label>
      <input type="number" id="roomWidth" value="20" step="any">
      <label>H:</label>
      <input type="number" id="roomHeight" value="30" step="any">
      <select id="roomUnits">
        <option value="ft">Feet</option>
        <option value="m">Meters</option>
      </select>
      <button id="applyRoomBtn">Apply Room</button>
    </div>

    <div class="row-right">
      <label>Rect:</label>
      <input type="text" id="itemName" placeholder="Tablesaw" size="10">
      <label>W:</label>
      <input type="number" id="itemWidth" value="3" step="any">
      <label>D:</label>
      <input type="number" id="itemDepth" value="2" step="any">
      <button id="addItemBtn">Add Rect</button>
    </div>
  </div>

  <!-- Row 2: Save/PDF (left) / Circle (right) -->
  <div class="controls-row">
    <div class="row-left">
      <button id="downloadBtn">Download JSON</button>
      <button id="uploadBtn">Upload JSON</button>
      <input type="file" id="fileInput" accept="application/json" style="display:none;">
      <label>PDF Header:</label>
      <input type="text" id="pdfHeader" value="Shop Layout">
      <button id="pdfBtn">Save PDF</button>
    </div>

    <div class="row-right">
      <label>Circle:</label>
      <input type="text" id="circleName" placeholder="Drill Press" size="10">
      <label>Dia:</label>
      <input type="number" id="circleDiameter" value="2" step="any">
      <button id="addCircleBtn">Add Circle</button>
    </div>
  </div>

  <!-- Row 3: Tools (left) / Wall Type (right) -->
  <div class="controls-row">
    <div class="row-left">
      <label>Tool:</label>
      <button id="toolSelectBtn" class="active">Select / Items</button>
      <button id="toolWallBtn">Add Wall</button>
      <button id="toolLabelBtn">Add Label</button>
    </div>
    <div class="row-right">
      <label>Wall Type:</label>
      <label><input type="radio" name="wallType" value="interior" checked>Interior</label>
      <label><input type="radio" name="wallType" value="exterior">Exterior</label>
    </div>
  </div>
</div>

<!-- Main layout -->
<div id="main">
  <!-- Canvas -->
  <div id="canvasContainer">
    <canvas id="layoutCanvas" tabindex="0"></canvas>
  </div>

  <!-- Sidebar -->
  <div id="sidebar">
    <h3>Item Details</h3>

    <div id="noSelection"><p>No item selected.</p></div>

    <div id="itemEditor" style="display:none;">
      <label>Name:</label>
      <input type="text" id="editName">

      <!-- Rectangle fields -->
      <div id="rectFields">
        <label>Width:</label>
        <input type="number" id="editWidth" step="any">

        <label>Depth:</label>
        <input type="number" id="editDepth" step="any">

        <label>Rotation (deg):</label>
        <input type="number" id="editRotation" step="any">
      </div>

      <!-- Circle fields -->
      <div id="circleFields" style="display:none;">
        <label>Diameter:</label>
        <input type="number" id="editDiameter" step="any">
      </div>

      <!-- Color fields -->
      <div id="colorFields">
        <label>Color:</label><br>
        <label><input type="radio" name="editColor" value="blue">Blue</label>
        <label><input type="radio" name="editColor" value="green">Green</label>
        <label><input type="radio" name="editColor" value="orange">Orange</label>
        <label><input type="radio" name="editColor" value="gray">Gray</label>
      </div>

      <button id="applyEditBtn">Apply Changes</button>
      <button id="deleteItemBtn" class="danger">Delete</button>
    </div>
  </div>
</div>

<div class="hint">
  Rectangles: left-click to select, drag to move, drag small circle to rotate, [ and ] to rotate with snap.  
  Circles: left-click to select, drag to move.  
  Walls: choose "Add Wall", click start (snaps to grid), click end (snaps). One wall per click of the tool.  
  Labels: choose "Add Label" and click to place text. One label per click of the tool.  
  Right-click and drag to pan. Mouse wheel to zoom.
</div>

<!-- jsPDF CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>
/* ===== INITIAL SETUP ===== */
const canvas = document.getElementById("layoutCanvas");
const ctx = canvas.getContext("2d");

let room = { width: 20, height: 30, units: "ft" };
let baseScale = 10;     // scale from room units to pixels (before zoom)
const padding = 30;

let items = [];   // {id, type: "rect"|"circle", name, width, depth, diameter, x, y, rotation, color}
let walls = [];   // {id, x1,y1,x2,y2, style: "interior"|"exterior"}
let labels = [];  // {id, text, x, y, size: "medium"}
let nextItemId = 1;
let nextWallId = 1;
let nextLabelId = 1;

let selectedItemId = null;
let selectedWallId = null;
let selectedLabelId = null;

let isDragging = false;
let dragItemId = null;
let dragOffset = { x:0, y:0 };

let isRotating = false;
let rotateItemId = null;
let rotateStartAngle = 0;
let rotateStartMouseAngle = 0;

// wall drag
let wallDragMode = null; // "line" | "end1" | "end2" | null
let wallDragData = null; // { wallId, startWorld, orig }

// label drag
let labelDragId = null;
let labelDragOffset = { x: 0, y: 0 };

let isDirty = false; // track unsaved changes

// Zoom + pan
let viewScale = 1;   // additional zoom factor
let offsetX = 0;     // pan in pixels
let offsetY = 0;
let isPanning = false;
let panLastX = 0;
let panLastY = 0;

// Tool mode
let toolMode = "select"; // "select" | "wall" | "label"
let wallDraftStart = null; // first click point in room coords for wall

function markDirty() {
  isDirty = true;
}
function markClean() {
  isDirty = false;
}

/* Warn if leaving page with unsaved changes */
window.addEventListener("beforeunload", (e) => {
  if (!isDirty) return;
  e.preventDefault();
  e.returnValue = "";
});

/* Prevent right-click menu on canvas (we use right-click for pan) */
canvas.addEventListener("contextmenu", (e) => e.preventDefault());

/* ===== GRID STEP / SNAP ===== */
function getMinorGridStep() {
  return room.units === "m" ? 0.1 : 0.25;
}
function getMajorGridStep() {
  return room.units === "m" ? 0.5 : 1.0;
}
function snapToGrid(v) {
  const step = getMinorGridStep();
  return Math.round(v / step) * step;
}

/* ===== CANVAS SIZING ===== */
function resizeCanvas() {
  const rect = document.getElementById("canvasContainer").getBoundingClientRect();
  canvas.width = rect.width;
  canvas.height = rect.height;
  computeBaseScale();
  // Reset zoom/pan on resize so it doesn't get weird
  viewScale = 1;
  offsetX = 0;
  offsetY = 0;
  draw();
}

function computeBaseScale() {
  const usableW = canvas.width - padding*2;
  const usableH = canvas.height - padding*2;
  baseScale = Math.min(usableW / room.width, usableH / room.height);
}

function effectiveScale() {
  return baseScale * viewScale;
}

function roomToCanvas(x,y){
  const s = effectiveScale();
  return {
    x: padding + offsetX + x * s,
    y: padding + offsetY + y * s
  };
}

function canvasToRoom(x,y){
  const s = effectiveScale();
  return {
    x: (x - padding - offsetX) / s,
    y: (y - padding - offsetY) / s
  };
}

/* ===== BOUNDS & CLAMPING (handles rotation) ===== */
function getItemBounds(item) {
  if (item.type === "circle") {
    const r = item.diameter / 2;
    return { halfW: r, halfH: r };
  } else { // rect
    const w = item.width;
    const d = item.depth;
    const a = item.rotation || 0;
    const cos = Math.cos(a);
    const sin = Math.sin(a);
    const halfW = 0.5 * (Math.abs(w * cos) + Math.abs(d * sin));
    const halfH = 0.5 * (Math.abs(w * sin) + Math.abs(d * cos));
    return { halfW, halfH };
  }
}

function clampItemInsideRoom(item) {
  const b = getItemBounds(item);
  item.x = Math.max(b.halfW, Math.min(room.width - b.halfW, item.x));
  item.y = Math.max(b.halfH, Math.min(room.height - b.halfH, item.y));
}

/* ===== ITEM COLORS ===== */
function getItemFillColor(color) {
  switch (color) {
    case "green":  return "#d6f5d6";
    case "orange": return "#ffe0b3";
    case "gray":   return "#e0e0e0";
    case "blue":
    default:       return "#d5e8ff";
  }
}

function getItemStrokeColor(color) {
  switch (color) {
    case "green":  return "#3c7a3c";
    case "orange": return "#b36b00";
    case "gray":   return "#555555";
    case "blue":
    default:       return "#555555";
  }
}

/* ===== DRAWING ===== */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawRoom();
  drawGrid();
  drawWalls();
  drawItems();
  drawLabels();
}

function drawRoom(){
  const tl = roomToCanvas(0,0);
  const br = roomToCanvas(room.width,room.height);
  ctx.strokeStyle="#000";
  ctx.lineWidth=2;
  ctx.strokeRect(tl.x,tl.y,br.x-tl.x,br.y-tl.y);
}

function drawGrid(){
  const major = getMajorGridStep();
  const minor = getMinorGridStep();
  ctx.save();

  ctx.strokeStyle="#eee";
  ctx.beginPath();
  for(let x=0; x<=room.width+1e-6; x+=minor){
    const p1=roomToCanvas(x,0), p2=roomToCanvas(x,room.height);
    ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y);
  }
  for(let y=0; y<=room.height+1e-6; y+=minor){
    const p1=roomToCanvas(0,y), p2=roomToCanvas(room.width,y);
    ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y);
  }
  ctx.stroke();

  ctx.strokeStyle="#ccc";
  ctx.beginPath();
  for(let x=0; x<=room.width+1e-6; x+=major){
    const p1=roomToCanvas(x,0), p2=roomToCanvas(x,room.height);
    ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y);
  }
  for(let y=0; y<=room.height+1e-6; y+=major){
    const p1=roomToCanvas(0,y), p2=roomToCanvas(room.width,y);
    ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y);
  }
  ctx.stroke();

  ctx.restore();
}

/* Walls */
function drawWalls() {
  walls.forEach(wall => {
    const p1 = roomToCanvas(wall.x1, wall.y1);
    const p2 = roomToCanvas(wall.x2, wall.y2);

    let isSelected = (wall.id === selectedWallId);

    if (wall.style === "exterior") {
      ctx.strokeStyle = isSelected ? "#ff0000" : "#000000";
      ctx.lineWidth = isSelected ? 8 : 6;
    } else {
      ctx.strokeStyle = isSelected ? "#ff0000" : "#666666";
      ctx.lineWidth = isSelected ? 5 : 3;
    }

    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();

    // Draw endpoint handles if selected
    if (isSelected) {
      ctx.fillStyle = "#ffffff";
      ctx.strokeStyle = "#ff0000";
      ctx.lineWidth = 2;
      [p1, p2].forEach(pt => {
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, 6, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
      });
    }
  });
}

/* Items */
function drawItems(){
  items.forEach(drawItem);
}

function drawItem(item){
  if (item.type === "circle") {
    drawCircleItem(item);
  } else {
    drawRectItem(item);
  }
}

function drawRectItem(item){
  const c = roomToCanvas(item.x,item.y);
  const s = effectiveScale();
  const w = item.width * s;
  const h = item.depth * s;

  const fillCol = getItemFillColor(item.color);
  const strokeCol = getItemStrokeColor(item.color);

  ctx.save();
  ctx.translate(c.x,c.y);
  ctx.rotate(item.rotation || 0);

  ctx.fillStyle = fillCol;
  ctx.strokeStyle = (item.id===selectedItemId ? "#06c" : strokeCol);
  ctx.lineWidth = (item.id===selectedItemId ? 2 : 1.2);

  ctx.fillRect(-w/2,-h/2,w,h);
  ctx.strokeRect(-w/2,-h/2,w,h);

  ctx.save();
  ctx.rotate(-(item.rotation || 0));
  ctx.fillStyle="#000";
  ctx.font="13px system-ui";
  ctx.textAlign="center";
  ctx.textBaseline="middle";
  ctx.fillText(item.name,0,0);
  ctx.restore();

  ctx.restore();

  if(item.id===selectedItemId) drawRotateHandle(item);
}

function drawCircleItem(item){
  const c = roomToCanvas(item.x,item.y);
  const s = effectiveScale();
  const r = (item.diameter/2) * s;

  const fillCol = getItemFillColor(item.color);
  const strokeCol = getItemStrokeColor(item.color);

  ctx.save();
  ctx.beginPath();
  ctx.arc(c.x, c.y, r, 0, Math.PI*2);
  ctx.fillStyle = fillCol;
  ctx.fill();
  ctx.strokeStyle = (item.id===selectedItemId ? "#06c" : strokeCol);
  ctx.lineWidth = (item.id===selectedItemId ? 2 : 1.2);
  ctx.stroke();

  ctx.fillStyle="#000";
  ctx.font="13px system-ui";
  ctx.textAlign="center";
  ctx.textBaseline="middle";
  ctx.fillText(item.name, c.x, c.y);
  ctx.restore();
}

/* Labels */
function drawLabels() {
  ctx.save();
  ctx.font = "14px system-ui";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  labels.forEach(label => {
    const p = roomToCanvas(label.x, label.y);
    ctx.fillStyle = "#444";
    ctx.fillText(label.text, p.x, p.y);

    if (label.id === selectedLabelId) {
      // Simple highlight box
      const paddingPx = 4;
      const textWidth = ctx.measureText(label.text).width;
      const boxW = textWidth + paddingPx*2;
      const boxH = 20;
      ctx.strokeStyle = "#ff0000";
      ctx.lineWidth = 1;
      ctx.strokeRect(p.x - boxW/2, p.y - boxH/2, boxW, boxH);
    }
  });

  ctx.restore();
}

/* Rotate handle */
function drawRotateHandle(item){
  if (item.type !== "rect") return; // circles donâ€™t rotate

  const c=roomToCanvas(item.x,item.y);
  const s = effectiveScale();
  const h=item.depth * s;
  const half=h/2, offset=20;
  const L=half+offset;
  const a = item.rotation || 0;

  const hx=c.x + L*Math.sin(a);
  const hy=c.y - L*Math.cos(a);

  ctx.save();
  ctx.fillStyle="#fff";
  ctx.strokeStyle="#06c";
  ctx.lineWidth=2;

  ctx.beginPath();
  ctx.arc(hx,hy,7,0,Math.PI*2);
  ctx.fill();
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(c.x,c.y);
  ctx.lineTo(hx,hy);
  ctx.stroke();

  ctx.restore();
}

/* ===== HIT TEST (ITEMS ONLY) ===== */
function getHit(px,py){
  // items only (walls & labels handled separately)
  for(let i=items.length-1;i>=0;i--){
    const item=items[i];
    if (item.type === "rect" && isRotateHandle(px,py,item)) {
      return {item,mode:"rotate"};
    }
    if (isInsideItem(px,py,item)) {
      return {item,mode:"move"};
    }
  }
  return null;
}

function isInsideItem(px,py,item){
  if (item.type === "circle") {
    const c = roomToCanvas(item.x,item.y);
    const s = effectiveScale();
    const r = (item.diameter/2) * s;
    return Math.hypot(px - c.x, py - c.y) <= r;
  } else {
    const c = roomToCanvas(item.x,item.y);
    let dx=px-c.x, dy=py-c.y;
    const a = item.rotation || 0;
    const cos=Math.cos(-a), sin=Math.sin(-a);
    let x=dx*cos - dy*sin;
    let y=dx*sin + dy*cos;
    const s = effectiveScale();
    const hw=item.width*s/2, hh=item.depth*s/2;
    return (x>=-hw && x<=hw && y>=-hh && y<=hh);
  }
}

function isRotateHandle(px,py,item){
  if (item.type !== "rect") return false;
  const c=roomToCanvas(item.x,item.y);
  const s = effectiveScale();
  const h=item.depth*s;
  const half=h/2, offset=20;
  const L=half+offset;
  const a = item.rotation || 0;

  const hx=c.x + L*Math.sin(a);
  const hy=c.y - L*Math.cos(a);

  return Math.hypot(px-hx,py-hy)<=10;
}

/* ===== WALL HIT TEST ===== */
function hitTestWall(px, py) {
  const endRadius = 10;      // px for endpoint
  const lineThreshold = 6;   // px for line

  for (let i = walls.length - 1; i >= 0; i--) {
    const wall = walls[i];
    const p1 = roomToCanvas(wall.x1, wall.y1);
    const p2 = roomToCanvas(wall.x2, wall.y2);

    const d1 = Math.hypot(px - p1.x, py - p1.y);
    if (d1 <= endRadius) {
      return { wall, mode: "end1" };
    }
    const d2 = Math.hypot(px - p2.x, py - p2.y);
    if (d2 <= endRadius) {
      return { wall, mode: "end2" };
    }

    // distance to line segment
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const len2 = dx*dx + dy*dy;
    if (len2 === 0) continue;
    let t = ((px - p1.x)*dx + (py - p1.y)*dy) / len2;
    t = Math.max(0, Math.min(1, t));
    const projX = p1.x + t*dx;
    const projY = p1.y + t*dy;
    const distLine = Math.hypot(px - projX, py - projY);
    if (distLine <= lineThreshold) {
      return { wall, mode: "line" };
    }
  }
  return null;
}

/* ===== LABEL HIT TEST ===== */
function hitTestLabel(px, py) {
  // simple radius around label center
  const radius = 10;
  for (let i = labels.length - 1; i >= 0; i--) {
    const label = labels[i];
    const p = roomToCanvas(label.x, label.y);
    if (Math.hypot(px - p.x, py - p.y) <= radius) {
      return label;
    }
  }
  return null;
}

/* ===== TOOL BUTTONS ===== */
const toolSelectBtn = document.getElementById("toolSelectBtn");
const toolWallBtn = document.getElementById("toolWallBtn");
const toolLabelBtn = document.getElementById("toolLabelBtn");

function setToolMode(mode) {
  toolMode = mode;
  wallDraftStart = null; // cancel any partial wall
  toolSelectBtn.classList.remove("active");
  toolWallBtn.classList.remove("active");
  toolLabelBtn.classList.remove("active");
  if (mode === "select") toolSelectBtn.classList.add("active");
  if (mode === "wall")   toolWallBtn.classList.add("active");
  if (mode === "label")  toolLabelBtn.classList.add("active");
}

toolSelectBtn.addEventListener("click", () => setToolMode("select"));
toolWallBtn.addEventListener("click", () => setToolMode("wall"));
toolLabelBtn.addEventListener("click", () => setToolMode("label"));

/* ===== MOUSE EVENTS ===== */
canvas.addEventListener("mousedown", e=>{
  const rect=canvas.getBoundingClientRect();
  const px=e.clientX-rect.left, py=e.clientY-rect.top;

  // Right-click: start panning
  if (e.button === 2) {
    isPanning = true;
    panLastX = e.clientX;
    panLastY = e.clientY;
    return;
  }

  // Left button only for drawing/selecting
  if (e.button !== 0) return;

  const world = canvasToRoom(px, py);

  // TOOL: WALL (single-use)
  if (toolMode === "wall") {
    const snapped = { x: snapToGrid(world.x), y: snapToGrid(world.y) };

    if (!wallDraftStart) {
      wallDraftStart = snapped;
    } else {
      const wallTypeInput = document.querySelector('input[name="wallType"]:checked');
      const style = wallTypeInput ? wallTypeInput.value : "interior";

      walls.push({
        id: nextWallId++,
        x1: wallDraftStart.x,
        y1: wallDraftStart.y,
        x2: snapped.x,
        y2: snapped.y,
        style
      });

      wallDraftStart = null;
      markDirty();
      setToolMode("select"); // single action
      draw();
    }
    return;
  }

  // TOOL: LABEL (single-use)
  if (toolMode === "label") {
    const text = prompt("Label text:", "");
    if (text && text.trim() !== "") {
      labels.push({
        id: nextLabelId++,
        text: text.trim(),
        x: world.x,
        y: world.y,
        size: "medium"
      });
      markDirty();
      draw();
    }
    setToolMode("select");
    return;
  }

  // TOOL: SELECT
  // 1) Items
  const hit=getHit(px,py);
  if(hit){
    selectedItemId=hit.item.id;
    selectedWallId=null;
    selectedLabelId=null;
    updateSidebar();

    if(hit.mode==="move"){
      isDragging=true; dragItemId=hit.item.id;
      const rp=world;
      dragOffset.x=rp.x-hit.item.x;
      dragOffset.y=rp.y-hit.item.y;
    }

    if(hit.mode==="rotate"){
      isRotating=true; rotateItemId=hit.item.id;
      const c=roomToCanvas(hit.item.x,hit.item.y);
      rotateStartMouseAngle=Math.atan2(py-c.y, px-c.x);
      rotateStartAngle=hit.item.rotation || 0;
    }

    draw();
    return;
  }

  // 2) Walls
  const wallHit = hitTestWall(px, py);
  if (wallHit) {
    selectedWallId = wallHit.wall.id;
    selectedItemId = null;
    selectedLabelId = null;
    updateSidebar(); // will show "no item selected"
    wallDragMode = wallHit.mode;
    wallDragData = {
      wallId: wallHit.wall.id,
      startWorld: world,
      orig: {
        x1: wallHit.wall.x1,
        y1: wallHit.wall.y1,
        x2: wallHit.wall.x2,
        y2: wallHit.wall.y2
      }
    };
    draw();
    return;
  }

  // 3) Labels
  const labelHit = hitTestLabel(px, py);
  if (labelHit) {
    selectedLabelId = labelHit.id;
    selectedItemId = null;
    selectedWallId = null;
    updateSidebar();
    labelDragId = labelHit.id;
    labelDragOffset.x = world.x - labelHit.x;
    labelDragOffset.y = world.y - labelHit.y;
    draw();
    return;
  }

  // Nothing hit
  selectedItemId=null;
  selectedWallId=null;
  selectedLabelId=null;
  wallDragMode = null;
  wallDragData = null;
  labelDragId = null;
  updateSidebar();
  draw();
});

canvas.addEventListener("mousemove", e=>{
  const rect=canvas.getBoundingClientRect();
  const px=e.clientX-rect.left, py=e.clientY-rect.top;
  const world = canvasToRoom(px, py);

  // Panning with right mouse
  if (isPanning) {
    const dx = e.clientX - panLastX;
    const dy = e.clientY - panLastY;
    panLastX = e.clientX;
    panLastY = e.clientY;
    offsetX += dx;
    offsetY += dy;
    draw();
    return;
  }

  // Dragging items
  if(isDragging && dragItemId){
    const item=items.find(i=>i.id===dragItemId);
    item.x=world.x-dragOffset.x;
    item.y=world.y-dragOffset.y;

    clampItemInsideRoom(item);
    markDirty();
    draw();
    updateSidebar();
  }

  // Rotating items
  if(isRotating && rotateItemId){
    const item=items.find(i=>i.id===rotateItemId);
    if (item.type !== "rect") return;

    const c=roomToCanvas(item.x,item.y);
    const ang=Math.atan2(py-c.y, px-c.x);
    item.rotation=rotateStartAngle + (ang-rotateStartMouseAngle);
    snapRotation(item);
    clampItemInsideRoom(item);
    markDirty();

    draw();
    updateSidebar();
  }

  // Dragging walls
  if (wallDragMode && wallDragData) {
    const wall = walls.find(w => w.id === wallDragData.wallId);
    if (!wall) return;

    if (wallDragMode === "line") {
      const dx = world.x - wallDragData.startWorld.x;
      const dy = world.y - wallDragData.startWorld.y;

      let nx1 = wallDragData.orig.x1 + dx;
      let ny1 = wallDragData.orig.y1 + dy;
      let nx2 = wallDragData.orig.x2 + dx;
      let ny2 = wallDragData.orig.y2 + dy;

      // snap endpoints to grid
      wall.x1 = snapToGrid(nx1);
      wall.y1 = snapToGrid(ny1);
      wall.x2 = snapToGrid(nx2);
      wall.y2 = snapToGrid(ny2);
    } else if (wallDragMode === "end1") {
      wall.x1 = snapToGrid(world.x);
      wall.y1 = snapToGrid(world.y);
    } else if (wallDragMode === "end2") {
      wall.x2 = snapToGrid(world.x);
      wall.y2 = snapToGrid(world.y);
    }

    markDirty();
    draw();
  }

  // Dragging labels
  if (labelDragId) {
    const label = labels.find(l => l.id === labelDragId);
    if (label) {
      label.x = world.x - labelDragOffset.x;
      label.y = world.y - labelDragOffset.y;
      markDirty();
      draw();
    }
  }
});

window.addEventListener("mouseup", e=>{
  isDragging=false;
  dragItemId=null;
  isRotating=false;
  rotateItemId=null;
  if (e.button === 2) {
    isPanning = false;
  }
  wallDragMode = null;
  wallDragData = null;
  labelDragId = null;
});

/* ===== MOUSE WHEEL ZOOM ===== */
canvas.addEventListener("wheel", (e)=>{
  e.preventDefault();

  const rect = canvas.getBoundingClientRect();
  const px = e.clientX - rect.left;
  const py = e.clientY - rect.top;

  // Room point under cursor BEFORE zoom
  const world = canvasToRoom(px, py);

  // gentler zoom speed
  const factor = (e.deltaY < 0 ? 1.05 : 0.95);

  let newViewScale = viewScale * factor;

  // Limit zoom-out so you can't go smaller than the base fit
  const minViewScale = 1;     // no zoom-out beyond the initial full-room view
  const maxViewScale = 6;
  newViewScale = Math.max(minViewScale, Math.min(maxViewScale, newViewScale));
  viewScale = newViewScale;

  // Keep cursor's room coordinate stable during zoom
  const s = effectiveScale();
  offsetX = px - padding - world.x * s;
  offsetY = py - padding - world.y * s;

  draw();
}, { passive: false });

/* ===== SNAP ROTATION ===== */
function snapRotation(item){
  const targets=[0,90,180,270].map(d=>d*Math.PI/180);
  let a=(item.rotation || 0)%(2*Math.PI);
  if(a<0)a+=2*Math.PI;

  let best=a, min=999;
  for(let t of targets){
    let diff=Math.abs(a-t);
    diff=Math.min(diff,2*Math.PI-diff);
    if(diff<min){min=diff; best=t;}
  }

  if(min < 5*Math.PI/180) item.rotation=best;
}

/* ===== KEYBOARD ROTATION ===== */
document.addEventListener("keydown", e=>{
  if(!selectedItemId)return;
  const item=items.find(i=>i.id===selectedItemId);
  if (!item || item.type !== "rect") return; // only rectangles rotate

  const step=5*Math.PI/180;
  if(e.key==="[") item.rotation = (item.rotation || 0) - step;
  if(e.key==="]") item.rotation = (item.rotation || 0) + step;

  snapRotation(item);
  clampItemInsideRoom(item);
  markDirty();
  draw();
  updateSidebar();
});

/* ===== ADD RECTANGLE ===== */
document.getElementById("addItemBtn").addEventListener("click", ()=>{
  const name=document.getElementById("itemName").value || ("Rect "+nextItemId);
  const w=parseFloat(document.getElementById("itemWidth").value);
  const d=parseFloat(document.getElementById("itemDepth").value);
  if(!(w>0 && d>0)) return alert("Invalid rectangle size.");

  const item={
    id:nextItemId++,
    type:"rect",
    name,
    width:w,
    depth:d,
    x:room.width/2,
    y:room.height/2,
    rotation:0,
    color:"blue"
  };
  clampItemInsideRoom(item);
  items.push(item);
  selectedItemId=item.id;
  selectedWallId=null;
  selectedLabelId=null;
  markDirty();

  draw(); updateSidebar();
});

/* ===== ADD CIRCLE ===== */
document.getElementById("addCircleBtn").addEventListener("click", ()=>{
  const name=document.getElementById("circleName").value || ("Circle "+nextItemId);
  const dia=parseFloat(document.getElementById("circleDiameter").value);
  if(!(dia>0)) return alert("Invalid circle diameter.");

  const item={
    id:nextItemId++,
    type:"circle",
    name,
    diameter:dia,
    x:room.width/2,
    y:room.height/2,
    rotation:0,
    color:"blue"
  };
  clampItemInsideRoom(item);
  items.push(item);
  selectedItemId=item.id;
  selectedWallId=null;
  selectedLabelId=null;
  markDirty();

  draw(); updateSidebar();
});

/* ===== SIDEBAR (ITEMS ONLY) ===== */
function updateSidebar(){
  const noSel=document.getElementById("noSelection");
  const editor=document.getElementById("itemEditor");
  const rectFields=document.getElementById("rectFields");
  const circleFields=document.getElementById("circleFields");

  if(!selectedItemId){
    noSel.style.display="block";
    editor.style.display="none";
    return;
  }

  const item=items.find(i=>i.id===selectedItemId);
  if (!item) {
    noSel.style.display="block";
    editor.style.display="none";
    return;
  }

  noSel.style.display="none";
  editor.style.display="block";

  document.getElementById("editName").value=item.name;

  if (item.type === "rect") {
    rectFields.style.display="block";
    circleFields.style.display="none";
    document.getElementById("editWidth").value=item.width;
    document.getElementById("editDepth").value=item.depth;
    document.getElementById("editRotation").value=((item.rotation || 0)*180/Math.PI).toFixed(2);
  } else {
    rectFields.style.display="none";
    circleFields.style.display="block";
    document.getElementById("editDiameter").value=item.diameter;
  }

  // Set color radios
  const colorRadios = document.querySelectorAll('input[name="editColor"]');
  colorRadios.forEach(r => {
    r.checked = (r.value === (item.color || "blue"));
  });
}

document.getElementById("applyEditBtn").addEventListener("click", ()=>{
  const item=items.find(i=>i.id===selectedItemId);
  if(!item)return;

  item.name=document.getElementById("editName").value;

  if (item.type === "rect") {
    let w=parseFloat(document.getElementById("editWidth").value);
    let d=parseFloat(document.getElementById("editDepth").value);
    if(!(w>0)) w=item.width;
    if(!(d>0)) d=item.depth;
    item.width=w;
    item.depth=d;

    let rDeg=parseFloat(document.getElementById("editRotation").value);
    if(!isNaN(rDeg)){
      item.rotation=rDeg*Math.PI/180;
      snapRotation(item);
    }
  } else { // circle
    let dia=parseFloat(document.getElementById("editDiameter").value);
    if(!(dia>0)) dia=item.diameter;
    item.diameter=dia;
  }

  // apply color
  const colorInput = document.querySelector('input[name="editColor"]:checked');
  if (colorInput) {
    item.color = colorInput.value;
  }

  clampItemInsideRoom(item);
  markDirty();
  draw(); 
  updateSidebar();
});

document.getElementById("deleteItemBtn").addEventListener("click", ()=>{
  items=items.filter(i=>i.id!==selectedItemId);
  selectedItemId=null;
  markDirty();
  draw(); updateSidebar();
});

/* ===== ROOM APPLY ===== */
document.getElementById("applyRoomBtn").addEventListener("click", ()=>{
  const w=parseFloat(document.getElementById("roomWidth").value);
  const h=parseFloat(document.getElementById("roomHeight").value);
  if(!(w>0 && h>0)) return alert("Invalid room dimensions.");

  room.width=w;
  room.height=h;
  room.units=document.getElementById("roomUnits").value;

  // Clamp all items to new room size
  items.forEach(clampItemInsideRoom);

  computeBaseScale();
  viewScale = 1;
  offsetX = 0;
  offsetY = 0;

  markDirty();
  draw();
});

/* ===== DOWNLOAD / UPLOAD JSON ===== */
document.getElementById("downloadBtn").addEventListener("click", ()=>{
  const blob=new Blob(
    [JSON.stringify({room,items,walls,labels,nextItemId,nextWallId,nextLabelId},null,2)],
    {type:"application/json"}
  );
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url; a.download="shop_layout.json"; a.click();
  URL.revokeObjectURL(url);
  markClean(); // user has just downloaded the current state
});

document.getElementById("uploadBtn").addEventListener("click", ()=>fileInput.click());

document.getElementById("fileInput").addEventListener("change", e=>{
  const file=e.target.files[0];
  if(!file)return;

  const reader=new FileReader();
  reader.onload=function(evt){
    const obj=JSON.parse(evt.target.result);
    room=obj.room;
    items=obj.items || [];
    walls=obj.walls || [];
    labels=obj.labels || [];
    nextItemId=obj.nextItemId || 1;
    nextWallId=obj.nextWallId || 1;
    nextLabelId=obj.nextLabelId || 1;

    // Ensure color + rotation defaults
    items.forEach(it=>{
      if (!it.type) it.type="rect";
      if (!it.color) it.color="blue";
      if (it.type==="circle" && typeof it.diameter!=="number") {
        it.type="rect";
      }
      if (it.type==="rect" && typeof it.rotation!=="number") {
        it.rotation=0;
      }
    });

    computeBaseScale();
    viewScale = 1;
    offsetX = 0;
    offsetY = 0;
    items.forEach(clampItemInsideRoom);
    selectedItemId=null;
    selectedWallId=null;
    selectedLabelId=null;
    markClean();
    draw(); 
    updateSidebar();
  };
  reader.readAsText(file);
  fileInput.value="";
});

/* ===== SAVE PDF (EXACT CANVAS SIZE + HEADER) ===== */
document.getElementById("pdfBtn").addEventListener("click", ()=>{
  const { jsPDF } = window.jspdf;
  const headerText = document.getElementById("pdfHeader").value || "Shop Layout";

  const dataUrl = canvas.toDataURL("image/png");

  const canvasWidth = canvas.width;
  const canvasHeight = canvas.height;

  const orientation = canvasWidth >= canvasHeight ? "landscape" : "portrait";

  const headerSpace = 40;
  const pageWidth = canvasWidth;
  const pageHeight = canvasHeight + headerSpace;

  const pdf = new jsPDF({
    orientation,
    unit: "pt",
    format: [pageWidth, pageHeight]
  });

  pdf.setFontSize(14);
  const textWidth = pdf.getTextWidth(headerText);
  const textX = (pageWidth - textWidth) / 2;
  const textY = 20;
  pdf.text(headerText, textX, textY);

  pdf.addImage(
    dataUrl,
    "PNG",
    0,
    headerSpace,
    canvasWidth,
    canvasHeight
  );

  pdf.save("shop_layout.pdf");
});

/* ===== INIT ===== */
window.addEventListener("resize", resizeCanvas);
resizeCanvas();
draw();
markClean(); // fresh start
</script>

</body>
</html>
