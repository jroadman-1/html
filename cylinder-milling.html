<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cylindrical Profile Generator - DXF</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        h1 { color: #333; margin-bottom: 10px; font-size: 28px; }
        .subtitle { color: #666; margin-bottom: 30px; font-size: 14px; }
        .section { margin-bottom: 30px; }
        .section-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e0e0e0;
        }
        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background: #fafafa;
            cursor: pointer;
            transition: all 0.3s;
        }
        .upload-area:hover { border-color: #007bff; background: #f0f8ff; }
        .upload-area.dragover { border-color: #007bff; background: #e3f2fd; }
        input[type="file"] { display: none; }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .control-group { display: flex; flex-direction: column; }
        label {
            font-weight: 500;
            margin-bottom: 8px;
            color: #555;
            font-size: 14px;
        }
        input[type="number"] {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        input[type="number"]:focus { outline: none; border-color: #007bff; }
        canvas {
            display: block;
            background: white;
            border: 1px solid #ccc;
            margin: 20px auto;
        }
        .button {
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            margin-right: 10px;
        }
        .button-primary { background: #007bff; color: white; }
        .button-primary:hover { background: #0056b3; }
        .button-success { background: #28a745; color: white; }
        .button-success:hover { background: #218838; }
        .button-success:disabled { background: #ccc; cursor: not-allowed; }
        .info-panel {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 4px;
            margin-top: 15px;
            font-size: 14px;
        }
        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #e0e0e0;
        }
        .info-row:last-child { border-bottom: none; }
        .instructions {
            padding: 15px;
            background: #e3f2fd;
            border-left: 4px solid #2196F3;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #1565C0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Cylindrical Profile Generator</h1>
        <p class="subtitle">Upload an SVG profile and generate G-code for 4-axis cylindrical turning</p>
        
        <div class="section">
            <div class="section-title">1. Machine Parameters</div>
            <div class="controls">
                <div class="control-group">
                    <label for="toolDiameter">Tool Diameter (inches):</label>
                    <input type="number" id="toolDiameter" value="0.09375" step="0.001" min="0.001">
                </div>
                <div class="control-group">
                    <label for="spindleRPM">Spindle RPM:</label>
                    <input type="number" id="spindleRPM" value="18000" step="100" min="100">
                </div>
                <div class="control-group">
                    <label for="aAxisSpeed">A-axis Speed (deg/min):</label>
                    <input type="number" id="aAxisSpeed" value="3600" step="100" min="100">
                </div>
                <div class="control-group">
                    <label for="feedRate">Feed Rate (IPM):</label>
                    <input type="number" id="feedRate" value="10" step="0.1" min="0.1">
                </div>
                <div class="control-group">
                    <label for="depthPerPass">Z Depth per Pass (inches):</label>
                    <input type="number" id="depthPerPass" value="0.020" step="0.001" min="0.001">
                </div>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title">2. Upload DXF Profile</div>
            <div class="instructions">
                <strong>DXF Format:</strong> Draw your profile in any CAD software (Fusion 360, AutoCAD, LibreCAD, etc.) as a polyline or spline.
                Horizontal axis = Z (along cylinder), Vertical axis = X (radius). Only the upper half (positive radius) will be used.
            </div>
            <div class="upload-area" id="uploadArea">
                <div style="font-size: 48px; margin-bottom: 10px;">üìÅ</div>
                <div style="font-size: 16px; margin-bottom: 5px;">Click to upload or drag and drop</div>
                <div style="font-size: 12px; color: #999;">DXF files only</div>
                <input type="file" id="fileInput" accept=".dxf">
            </div>
            <div id="svgInfo" style="display: none;" class="info-panel">
                <div class="info-row">
                    <span>File:</span>
                    <span id="fileName">-</span>
                </div>
                <div class="info-row">
                    <span>Profile Points:</span>
                    <span id="pointCount">-</span>
                </div>
                <div class="info-row">
                    <span>Max Radius:</span>
                    <span id="maxRadius">-</span>
                </div>
                <div class="info-row">
                    <span>Profile Length (Z):</span>
                    <span id="profileLength">-</span>
                </div>
            </div>
            
            <canvas id="profileCanvas" width="800" height="400" style="display: none;"></canvas>
        </div>
        
        <div class="section">
            <div class="section-title">3. Generate G-code</div>
            <button class="button button-success" id="generateBtn" disabled>Generate G-code</button>
            <button class="button button-success" id="downloadBtn" disabled>Download G-code</button>
        </div>
    </div>

    <script>
        let profilePoints = [];
        let generatedGCode = null;
        let uploadedFileName = '';
        
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const canvas = document.getElementById('profileCanvas');
        const ctx = canvas.getContext('2d');
        
        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) handleFile(e.dataTransfer.files[0]);
        });
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) handleFile(e.target.files[0]);
        });
        
        function handleFile(file) {
            if (!file.name.toLowerCase().endsWith('.dxf')) {
                alert('Please upload a DXF file');
                return;
            }
            
            uploadedFileName = file.name;
            const reader = new FileReader();
            reader.onload = (e) => parseDXF(e.target.result);
            reader.readAsText(file);
        }
        
        function parseDXF(dxfContent) {
            const lines = dxfContent.split('\n').map(l => l.trim());
            profilePoints = [];
            
            let i = 0;
            while (i < lines.length) {
                // Look for LINE entities
                if (lines[i] === 'LINE') {
                    let x1, y1, z1, x2, y2, z2;
                    
                    // Scan ahead to find coordinates
                    for (let j = i; j < Math.min(i + 50, lines.length); j++) {
                        if (lines[j] === '10') x1 = parseFloat(lines[j + 1]);
                        else if (lines[j] === '20') y1 = parseFloat(lines[j + 1]);
                        else if (lines[j] === '30') z1 = parseFloat(lines[j + 1]);
                        else if (lines[j] === '11') x2 = parseFloat(lines[j + 1]);
                        else if (lines[j] === '21') y2 = parseFloat(lines[j + 1]);
                        else if (lines[j] === '31') z2 = parseFloat(lines[j + 1]);
                        
                        // Stop at next entity
                        if (j > i && lines[j] === '0') break;
                    }
                    
                    // Add both endpoints if valid
                    if (x1 !== undefined && z1 !== undefined) {
                        profilePoints.push({ x: Math.abs(z1), y: x1 });  // x=radius (abs of DXF Z), y=position (DXF X)
                    }
                    if (x2 !== undefined && z2 !== undefined) {
                        profilePoints.push({ x: Math.abs(z2), y: x2 });
                    }
                }
                
                // Look for LWPOLYLINE vertices
                else if (lines[i] === 'LWPOLYLINE') {
                    for (let j = i; j < Math.min(i + 1000, lines.length); j++) {
                        if (lines[j] === '10') {
                            const x = parseFloat(lines[j + 1]);
                            // Find corresponding 20 (Y coordinate)
                            for (let k = j; k < Math.min(j + 10, lines.length); k++) {
                                if (lines[k] === '20') {
                                    const y = parseFloat(lines[k + 1]);
                                    profilePoints.push({ x: x, y: y });
                                    break;
                                }
                            }
                        }
                        if (lines[j] === '0' && j > i + 10) break;
                    }
                }
                
                i++;
            }
            
            if (profilePoints.length < 2) {
                alert('No valid profile found in DXF. Found ' + profilePoints.length + ' points.');
                return;
            }
            
            // Remove duplicates (lines share endpoints)
            const uniquePoints = [];
            profilePoints.forEach(p => {
                const isDuplicate = uniquePoints.some(up => 
                    Math.abs(up.x - p.x) < 0.0001 && Math.abs(up.y - p.y) < 0.0001
                );
                if (!isDuplicate) {
                    uniquePoints.push(p);
                }
            });
            
            profilePoints = uniquePoints;
            
            // Normalize and filter points
            normalizePoints();
            displayProfile();
            updateInfo();
        }
        
        function normalizePoints() {
            if (profilePoints.length === 0) return;
            
            // Find bounds
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            profilePoints.forEach(p => {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y);
                maxY = Math.max(maxY, p.y);
            });
            
            // Convert to inches (assume SVG units are arbitrary, normalize to 0-1 inch range)
            const scaleX = maxX - minX;
            const scaleY = maxY - minY;
            const scale = Math.max(scaleX, scaleY);
            
            profilePoints = profilePoints.map(p => ({
                z: (p.x - minX) / scale,  // Horizontal = Z
                x: (maxY - p.y) / scale   // Vertical flipped = X (radius)
            }));
            
            // Filter out negative X (below centerline)
            profilePoints = profilePoints.filter(p => p.x >= 0);
            
            // Sort by Z
            profilePoints.sort((a, b) => a.z - b.z);
        }
        
        function displayProfile() {
            canvas.style.display = 'block';
            const scale = 300;
            const offsetX = 50;
            const offsetY = canvas.height - 50;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw axes
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(offsetX, offsetY);
            ctx.lineTo(canvas.width - 50, offsetY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(offsetX, offsetY);
            ctx.lineTo(offsetX, 50);
            ctx.stroke();
            
            ctx.fillStyle = '#333';
            ctx.font = '12px sans-serif';
            ctx.fillText('Z (along cylinder)', canvas.width - 150, offsetY + 20);
            ctx.fillText('X (radius)', offsetX + 10, 40);
            
            // Draw profile
            if (profilePoints.length > 1) {
                ctx.strokeStyle = '#2196F3';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                profilePoints.forEach((p, i) => {
                    const px = offsetX + p.z * scale;
                    const py = offsetY - p.x * scale;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                });
                
                ctx.stroke();
                
                // Draw points
                ctx.fillStyle = '#2196F3';
                profilePoints.forEach(p => {
                    const px = offsetX + p.z * scale;
                    const py = offsetY - p.x * scale;
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        }
        
        function updateInfo() {
            document.getElementById('svgInfo').style.display = 'block';
            document.getElementById('fileName').textContent = uploadedFileName;
            document.getElementById('pointCount').textContent = profilePoints.length;
            
            const maxX = Math.max(...profilePoints.map(p => p.x));
            const minZ = Math.min(...profilePoints.map(p => p.z));
            const maxZ = Math.max(...profilePoints.map(p => p.z));
            
            document.getElementById('maxRadius').textContent = maxX.toFixed(4) + '"';
            document.getElementById('profileLength').textContent = (maxZ - minZ).toFixed(4) + '"';
            
            document.getElementById('generateBtn').disabled = profilePoints.length < 2;
        }
        
        document.getElementById('generateBtn').addEventListener('click', generateGCode);
        document.getElementById('downloadBtn').addEventListener('click', downloadGCode);
        
        function generateGCode() {
            const toolDia = parseFloat(document.getElementById('toolDiameter').value);
            const toolRadius = toolDia / 2;
            const spindleRPM = parseInt(document.getElementById('spindleRPM').value);
            const aAxisSpeed = parseFloat(document.getElementById('aAxisSpeed').value);
            const feedRate = parseFloat(document.getElementById('feedRate').value);
            const depthPerPass = parseFloat(document.getElementById('depthPerPass').value);
            
            // Apply tool offset (add radius to X values)
            const offsetPoints = profilePoints.map(p => ({
                x: p.x + toolRadius,
                z: p.z
            }));
            
            const maxZ = Math.max(...offsetPoints.map(p => p.z));
            const numPasses = Math.ceil(maxZ / depthPerPass);
            
            let gcode = [];
            gcode.push('%');
            gcode.push('(CYLINDRICAL PROFILE - CNC TURNING)');
            gcode.push(`(TOOL DIA: ${toolDia}")`);
            gcode.push(`(SPINDLE: ${spindleRPM} RPM)`);
            gcode.push(`(A-AXIS: ${aAxisSpeed} deg/min continuous)`);
            gcode.push(`(FEED: ${feedRate} IPM)`);
            gcode.push(`(PASSES: ${numPasses})`);
            gcode.push('');
            gcode.push('G90 G94 G17');
            gcode.push('G20');
            gcode.push('G53 G0 Z-0.5');
            gcode.push('T1 M6');
            gcode.push(`S${spindleRPM} M3`);
            gcode.push('G54');
            gcode.push('M8');
            gcode.push('');
            
            // Start A-axis rotation
            gcode.push(`(Start continuous A-axis rotation at ${aAxisSpeed} deg/min)`);
            gcode.push('G0 A0.0');
            gcode.push('');
            
            for (let pass = 1; pass <= numPasses; pass++) {
                const currentMaxZ = Math.min(pass * depthPerPass, maxZ);
                
                gcode.push(`(PASS ${pass} - Z depth: ${currentMaxZ.toFixed(4)})`);
                
                // Rapid to start
                gcode.push(`G0 X${(offsetPoints[0].x + 0.1).toFixed(4)}`);
                gcode.push(`G0 Z${(offsetPoints[0].z - 0.05).toFixed(4)}`);
                
                // Feed into position
                gcode.push(`G1 X${offsetPoints[0].x.toFixed(4)} F${feedRate}`);
                gcode.push(`G1 Z${offsetPoints[0].z.toFixed(4)}`);
                
                // Follow profile while A rotates
                let currentAngle = 0;
                const degreesPerInch = aAxisSpeed / feedRate;
                
                for (let i = 1; i < offsetPoints.length; i++) {
                    const p = offsetPoints[i];
                    
                    // Only cut up to current depth
                    if (p.z > currentMaxZ) break;
                    
                    // Calculate A rotation based on Z travel
                    const deltaZ = p.z - offsetPoints[i-1].z;
                    currentAngle += deltaZ * degreesPerInch;
                    
                    gcode.push(`G1 X${p.x.toFixed(4)} Z${p.z.toFixed(4)} A${currentAngle.toFixed(3)}`);
                }
                
                // Retract
                gcode.push(`G0 X${(offsetPoints[0].x + 0.2).toFixed(4)}`);
                gcode.push('G0 Z0.0');
                gcode.push('');
            }
            
            gcode.push('G0 A0.0');
            gcode.push('M5');
            gcode.push('M9');
            gcode.push('G53 G0 Z-0.5');
            gcode.push('M30');
            gcode.push('%');
            
            generatedGCode = gcode.join('\n');
            alert(`G-code generated!\nPasses: ${numPasses}`);
            document.getElementById('downloadBtn').disabled = false;
        }
        
        function downloadGCode() {
            if (!generatedGCode) return;
            const blob = new Blob([generatedGCode], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'cylindrical_turning.nc';
            a.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
