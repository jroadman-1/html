<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G-Code Path Visualizer</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
        }
        h1 {
            text-align: center;
            color: #00d4ff;
            margin-bottom: 5px;
        }
        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 20px;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
        .panel {
            background: #252542;
            border-radius: 8px;
            padding: 20px;
        }
        .panel h2 {
            margin: 0 0 15px 0;
            color: #00d4ff;
            font-size: 18px;
        }
        #gcode-input {
            width: 100%;
            height: 400px;
            background: #0a0a15;
            border: 1px solid #444;
            border-radius: 4px;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            resize: vertical;
        }
        #gcode-input:focus {
            outline: none;
            border-color: #00d4ff;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 20px;
            font-size: 14px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .visualize-btn {
            background: #00d4ff;
            color: #1a1a2e;
            font-weight: bold;
        }
        .visualize-btn:hover {
            background: #00b8e6;
        }
        .clear-btn {
            background: #ff4757;
            color: #fff;
        }
        .clear-btn:hover {
            background: #e6404f;
        }
        .zoom-btn {
            background: #444;
            color: #fff;
            padding: 10px 15px;
        }
        .zoom-btn:hover {
            background: #555;
        }
        .canvas-container {
            position: relative;
            background: #0a0a15;
            border: 1px solid #444;
            border-radius: 4px;
            overflow: hidden;
        }
        #path-canvas {
            display: block;
            width: 100%;
            height: 450px;
        }
        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #aaa;
        }
        .legend-line {
            width: 30px;
            height: 3px;
            border-radius: 2px;
        }
        .legend-rapid {
            background: #ff6b6b;
            opacity: 0.6;
        }
        .legend-cut {
            background: #00cc66;
        }
        .legend-start {
            width: 12px;
            height: 12px;
            background: #00d4ff;
            border-radius: 50%;
        }
        .legend-end {
            width: 12px;
            height: 12px;
            background: #ff4757;
            border-radius: 50%;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        .stat {
            background: #1a1a2e;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #00d4ff;
        }
        .stat-label {
            font-size: 11px;
            color: #888;
            margin-top: 4px;
        }
        .info-box {
            background: #1a2a3a;
            border-left: 4px solid #00d4ff;
            padding: 12px;
            margin-bottom: 20px;
            border-radius: 0 8px 8px 0;
            font-size: 13px;
            color: #aaa;
        }
        .status {
            text-align: center;
            padding: 10px;
            margin-top: 15px;
            border-radius: 4px;
            display: none;
        }
        .status.success {
            display: block;
            background: #1a3a1a;
            color: #00cc66;
        }
        .status.error {
            display: block;
            background: #3a1a1a;
            color: #ff4757;
        }
        .view-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 15px;
        }
        .view-controls label {
            color: #aaa;
            font-size: 13px;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
        }
        .checkbox-label input {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>G-Code Path Visualizer</h1>
    <p class="subtitle">Paste your G-code to see a top-down view of the cutting path</p>

    <div class="info-box">
        <strong>Supports:</strong> G0/G1 linear moves, G2/G3 arcs, G90/G91 modes, variables (#1=value), expressions (#1=[#1/2+.032]).
        Rapids shown in red (dashed), cuts in green (solid).
    </div>

    <div class="container">
        <div class="panel">
            <h2>G-Code Input</h2>
            <textarea id="gcode-input" placeholder="Paste your G-code here..."></textarea>
            <div class="controls">
                <button class="visualize-btn" onclick="visualize()">Visualize Path</button>
                <button class="clear-btn" onclick="clearAll()">Clear</button>
            </div>
            <div class="status" id="status"></div>
        </div>

        <div class="panel">
            <h2>Top View (X-Y Plane)</h2>
            <div class="canvas-container">
                <canvas id="path-canvas"></canvas>
            </div>
            <div class="view-controls">
                <button class="zoom-btn" onclick="zoomIn()">Zoom +</button>
                <button class="zoom-btn" onclick="zoomOut()">Zoom âˆ’</button>
                <button class="zoom-btn" onclick="resetView()">Fit</button>
                <label class="checkbox-label">
                    <input type="checkbox" id="show-rapids" checked onchange="redraw()">
                    Show Rapids
                </label>
                <label class="checkbox-label">
                    <input type="checkbox" id="show-grid" checked onchange="redraw()">
                    Show Grid
                </label>
            </div>
            <div class="legend">
                <div class="legend-item"><div class="legend-line legend-rapid"></div> Rapid (G0)</div>
                <div class="legend-item"><div class="legend-line legend-cut"></div> Cut (G1)</div>
                <div class="legend-item"><div class="legend-start"></div> Start</div>
                <div class="legend-item"><div class="legend-end"></div> End</div>
            </div>
            <div class="stats" id="stats">
                <div class="stat">
                    <div class="stat-value" id="stat-moves">0</div>
                    <div class="stat-label">Total Moves</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="stat-rapids">0</div>
                    <div class="stat-label">Rapids</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="stat-cuts">0</div>
                    <div class="stat-label">Cuts</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="stat-xrange">0</div>
                    <div class="stat-label">X Range</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="stat-yrange">0</div>
                    <div class="stat-label">Y Range</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('path-canvas');
        const ctx = canvas.getContext('2d');
        
        let paths = [];
        let bounds = { minX: 0, maxX: 0, minY: 0, maxY: 0 };
        let zoom = 1;
        let panX = 0;
        let panY = 0;

        function initCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }

        function parseGcode(gcode) {
            const lines = gcode.split('\n');
            const variables = {};
            let currentPos = { x: 0, y: 0, z: 0 };
            let isAbsolute = true; // G90 default
            let currentMode = null; // G0, G1, G2, G3
            const parsedPaths = [];
            
            for (let line of lines) {
                // Remove comments
                line = line.replace(/\(.*?\)/g, '').trim();
                if (!line || line.startsWith('%')) continue;
                
                // Handle variable assignments: #1=1.725 or #1=[#1/2]
                const varAssign = line.match(/#(\d+)\s*=\s*(.+)/);
                if (varAssign) {
                    const varNum = varAssign[1];
                    let expr = varAssign[2].trim();
                    
                    // Evaluate expression
                    if (expr.startsWith('[') && expr.endsWith(']')) {
                        expr = expr.slice(1, -1);
                    }
                    
                    // Replace variable references
                    expr = expr.replace(/#(\d+)/g, (_, num) => variables[num] || 0);
                    
                    try {
                        variables[varNum] = eval(expr);
                    } catch (e) {
                        variables[varNum] = parseFloat(expr) || 0;
                    }
                    continue;
                }
                
                // Check for G90/G91
                if (line.includes('G90')) isAbsolute = true;
                if (line.includes('G91')) isAbsolute = false;
                
                // Check for movement mode
                if (line.includes('G0') || line.includes('G00')) currentMode = 'rapid';
                if (line.includes('G1') || line.includes('G01')) currentMode = 'cut';
                if (line.includes('G2') || line.includes('G02')) currentMode = 'arcCW';
                if (line.includes('G3') || line.includes('G03')) currentMode = 'arcCCW';
                
                // Parse coordinates
                const coords = {};
                
                // Handle X, Y, Z with possible variable references or negative signs
                const xMatch = line.match(/X\s*(-?)#?(\d+\.?\d*)/i);
                const yMatch = line.match(/Y\s*(-?)#?(\d+\.?\d*)/i);
                const zMatch = line.match(/Z\s*(-?)#?(\d+\.?\d*)/i);
                const iMatch = line.match(/I\s*(-?\d*\.?\d+)/i);
                const jMatch = line.match(/J\s*(-?\d*\.?\d+)/i);
                
                if (xMatch) {
                    const neg = xMatch[1] === '-';
                    const val = line.match(/X\s*-?#(\d+)/i) 
                        ? variables[line.match(/X\s*-?#(\d+)/i)[1]] || 0
                        : parseFloat(xMatch[2]);
                    coords.x = neg ? -val : val;
                }
                if (yMatch) {
                    const neg = yMatch[1] === '-';
                    const val = line.match(/Y\s*-?#(\d+)/i)
                        ? variables[line.match(/Y\s*-?#(\d+)/i)[1]] || 0
                        : parseFloat(yMatch[2]);
                    coords.y = neg ? -val : val;
                }
                if (zMatch) {
                    const neg = zMatch[1] === '-';
                    const val = parseFloat(zMatch[2]);
                    coords.z = neg ? -val : val;
                }
                if (iMatch) coords.i = parseFloat(iMatch[1]);
                if (jMatch) coords.j = parseFloat(jMatch[1]);
                
                // If we have coordinates and a mode, record the path
                if ((coords.x !== undefined || coords.y !== undefined) && currentMode) {
                    const startPos = { ...currentPos };
                    
                    if (isAbsolute) {
                        if (coords.x !== undefined) currentPos.x = coords.x;
                        if (coords.y !== undefined) currentPos.y = coords.y;
                        if (coords.z !== undefined) currentPos.z = coords.z;
                    } else {
                        if (coords.x !== undefined) currentPos.x += coords.x;
                        if (coords.y !== undefined) currentPos.y += coords.y;
                        if (coords.z !== undefined) currentPos.z += coords.z;
                    }
                    
                    const path = {
                        type: currentMode,
                        from: startPos,
                        to: { ...currentPos }
                    };
                    
                    // Add arc center for G2/G3
                    if ((currentMode === 'arcCW' || currentMode === 'arcCCW') && 
                        (coords.i !== undefined || coords.j !== undefined)) {
                        path.center = {
                            x: startPos.x + (coords.i || 0),
                            y: startPos.y + (coords.j || 0)
                        };
                    }
                    
                    parsedPaths.push(path);
                }
            }
            
            return parsedPaths;
        }

        function calculateBounds(parsedPaths) {
            if (parsedPaths.length === 0) {
                return { minX: -1, maxX: 1, minY: -1, maxY: 1 };
            }
            
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            for (const path of parsedPaths) {
                minX = Math.min(minX, path.from.x, path.to.x);
                maxX = Math.max(maxX, path.from.x, path.to.x);
                minY = Math.min(minY, path.from.y, path.to.y);
                maxY = Math.max(maxY, path.from.y, path.to.y);
            }
            
            // Add padding
            const padX = (maxX - minX) * 0.1 || 0.5;
            const padY = (maxY - minY) * 0.1 || 0.5;
            
            return {
                minX: minX - padX,
                maxX: maxX + padX,
                minY: minY - padY,
                maxY: maxY + padY
            };
        }

        function drawGrid() {
            if (!document.getElementById('show-grid').checked) return;
            
            const rect = canvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            
            const scale = getUniformScale(width, height);
            const viewRangeX = width / scale;
            const viewRangeY = height / scale;
            
            // Determine grid spacing based on visible range
            const maxRange = Math.max(viewRangeX, viewRangeY);
            let gridSize = 0.1;
            const maxGridLines = 20;
            while (maxRange / gridSize > maxGridLines) {
                gridSize *= 2;
            }
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 0.5;
            
            const centerX = (bounds.minX + bounds.maxX) / 2 + panX;
            const centerY = (bounds.minY + bounds.maxY) / 2 + panY;
            
            // Draw vertical lines
            const startX = Math.floor((centerX - viewRangeX / 2) / gridSize) * gridSize;
            for (let x = startX; x < centerX + viewRangeX / 2; x += gridSize) {
                const screenX = worldToScreenX(x, width, height);
                ctx.beginPath();
                ctx.moveTo(screenX, 0);
                ctx.lineTo(screenX, height);
                ctx.stroke();
            }
            
            // Draw horizontal lines
            const startY = Math.floor((centerY - viewRangeY / 2) / gridSize) * gridSize;
            for (let y = startY; y < centerY + viewRangeY / 2; y += gridSize) {
                const screenY = worldToScreenY(y, width, height);
                ctx.beginPath();
                ctx.moveTo(0, screenY);
                ctx.lineTo(width, screenY);
                ctx.stroke();
            }
            
            // Draw origin axes
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 1;
            
            const originX = worldToScreenX(0, width, height);
            const originY = worldToScreenY(0, width, height);
            
            if (originX >= 0 && originX <= width) {
                ctx.beginPath();
                ctx.moveTo(originX, 0);
                ctx.lineTo(originX, height);
                ctx.stroke();
            }
            
            if (originY >= 0 && originY <= height) {
                ctx.beginPath();
                ctx.moveTo(0, originY);
                ctx.lineTo(width, originY);
                ctx.stroke();
            }
        }

        function getUniformScale(width, height) {
            const rangeX = bounds.maxX - bounds.minX;
            const rangeY = bounds.maxY - bounds.minY;
            
            // Prevent division by zero
            if (rangeX <= 0 || rangeY <= 0) {
                return zoom * 100; // Default scale
            }
            
            // Use the larger range to maintain aspect ratio
            const scaleX = width / rangeX;
            const scaleY = height / rangeY;
            
            // Pick the smaller scale so everything fits
            return Math.min(scaleX, scaleY) * zoom;
        }

        function worldToScreenX(x, width, height) {
            const centerX = (bounds.minX + bounds.maxX) / 2 + panX;
            const scale = getUniformScale(width, height);
            return (x - centerX) * scale + width / 2;
        }

        function worldToScreenY(y, width, height) {
            const centerY = (bounds.minY + bounds.maxY) / 2 + panY;
            const scale = getUniformScale(width, height);
            return -(y - centerY) * scale + height / 2; // Flip Y
        }

        function drawPaths() {
            const rect = canvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            const showRapids = document.getElementById('show-rapids').checked;
            
            for (const path of paths) {
                const fromX = worldToScreenX(path.from.x, width, height);
                const fromY = worldToScreenY(path.from.y, width, height);
                const toX = worldToScreenX(path.to.x, width, height);
                const toY = worldToScreenY(path.to.y, width, height);
                
                ctx.beginPath();
                
                if (path.type === 'rapid') {
                    if (!showRapids) continue;
                    ctx.strokeStyle = 'rgba(255, 107, 107, 0.5)';
                    ctx.setLineDash([5, 5]);
                    ctx.lineWidth = 1;
                } else if (path.type === 'cut') {
                    ctx.strokeStyle = '#00cc66';
                    ctx.setLineDash([]);
                    ctx.lineWidth = 2;
                } else if (path.type === 'arcCW' || path.type === 'arcCCW') {
                    ctx.strokeStyle = '#00cc66';
                    ctx.setLineDash([]);
                    ctx.lineWidth = 2;
                    
                    // Draw arc if we have center
                    if (path.center) {
                        const centerScreenX = worldToScreenX(path.center.x, width, height);
                        const centerScreenY = worldToScreenY(path.center.y, width, height);
                        const radius = Math.sqrt(
                            Math.pow(fromX - centerScreenX, 2) + 
                            Math.pow(fromY - centerScreenY, 2)
                        );
                        const startAngle = Math.atan2(fromY - centerScreenY, fromX - centerScreenX);
                        const endAngle = Math.atan2(toY - centerScreenY, toX - centerScreenX);
                        
                        ctx.arc(centerScreenX, centerScreenY, radius, startAngle, endAngle, path.type === 'arcCCW');
                        ctx.stroke();
                        continue;
                    }
                }
                
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(toX, toY);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Draw start point
            if (paths.length > 0) {
                const startX = worldToScreenX(paths[0].from.x, width, height);
                const startY = worldToScreenY(paths[0].from.y, width, height);
                ctx.beginPath();
                ctx.arc(startX, startY, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#00d4ff';
                ctx.fill();
                
                // Draw end point
                const lastPath = paths[paths.length - 1];
                const endX = worldToScreenX(lastPath.to.x, width, height);
                const endY = worldToScreenY(lastPath.to.y, width, height);
                ctx.beginPath();
                ctx.arc(endX, endY, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#ff4757';
                ctx.fill();
            }
        }

        function redraw() {
            initCanvas();
            const rect = canvas.getBoundingClientRect();
            ctx.clearRect(0, 0, rect.width, rect.height);
            drawGrid();
            drawPaths();
        }

        function visualize() {
            const gcode = document.getElementById('gcode-input').value;
            
            if (!gcode.trim()) {
                showStatus('Please paste some G-code first.', 'error');
                return;
            }
            
            paths = parseGcode(gcode);
            
            if (paths.length === 0) {
                showStatus('No movement commands found in G-code.', 'error');
                return;
            }
            
            bounds = calculateBounds(paths);
            zoom = 1;
            panX = 0;
            panY = 0;
            
            redraw();
            updateStats();
            showStatus(`Visualized ${paths.length} moves.`, 'success');
        }

        function updateStats() {
            const rapids = paths.filter(p => p.type === 'rapid').length;
            const cuts = paths.filter(p => p.type === 'cut' || p.type === 'arcCW' || p.type === 'arcCCW').length;
            
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            for (const path of paths) {
                minX = Math.min(minX, path.from.x, path.to.x);
                maxX = Math.max(maxX, path.from.x, path.to.x);
                minY = Math.min(minY, path.from.y, path.to.y);
                maxY = Math.max(maxY, path.from.y, path.to.y);
            }
            
            document.getElementById('stat-moves').textContent = paths.length;
            document.getElementById('stat-rapids').textContent = rapids;
            document.getElementById('stat-cuts').textContent = cuts;
            document.getElementById('stat-xrange').textContent = (maxX - minX).toFixed(3) + '"';
            document.getElementById('stat-yrange').textContent = (maxY - minY).toFixed(3) + '"';
        }

        function zoomIn() {
            zoom *= 1.5;
            redraw();
        }

        function zoomOut() {
            zoom /= 1.5;
            if (zoom < 0.1) zoom = 0.1;
            redraw();
        }

        function resetView() {
            zoom = 1;
            panX = 0;
            panY = 0;
            redraw();
        }

        function clearAll() {
            document.getElementById('gcode-input').value = '';
            paths = [];
            bounds = { minX: -1, maxX: 1, minY: -1, maxY: 1 };
            zoom = 1;
            panX = 0;
            panY = 0;
            redraw();
            
            document.getElementById('stat-moves').textContent = '0';
            document.getElementById('stat-rapids').textContent = '0';
            document.getElementById('stat-cuts').textContent = '0';
            document.getElementById('stat-xrange').textContent = '0';
            document.getElementById('stat-yrange').textContent = '0';
        }

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status ' + type;
            setTimeout(() => {
                status.className = 'status';
            }, 3000);
        }

        // Handle window resize
        window.addEventListener('resize', redraw);
        
        // Initialize
        initCanvas();
        drawGrid();

        // Pan with mouse drag
        let isDragging = false;
        let lastMouseX, lastMouseY;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const rect = canvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            const scale = getUniformScale(width, height);
            
            const dx = e.clientX - lastMouseX;
            const dy = e.clientY - lastMouseY;
            
            panX -= dx / scale;
            panY += dy / scale; // Flip for Y
            
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            redraw();
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.style.cursor = 'grab';

        // Zoom with scroll wheel
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.deltaY < 0) {
                zoom *= 1.2;
            } else {
                zoom /= 1.2;
                if (zoom < 0.1) zoom = 0.1;
            }
            redraw();
        });
    </script>
</body>
</html>
