<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Shop Layout Planner</title>
<style>
  body {
    font-family: system-ui, sans-serif;
    margin: 0;
    padding: 0;
    height: 100vh;
    display: flex;
    flex-direction: column;
    background: #f5f5f5;
    box-sizing: border-box;
  }
  
  * {
    box-sizing: border-box;
  }

  header {
    padding: 8px 12px;
    background: #333;
    color: #fff;
    font-size: 18px;
  }

  .controls {
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 10px 12px;
    background: #fafafa;
    border-bottom: 1px solid #ddd;
  }

  .controls-row {
    display: flex;
    justify-content: flex-start;
    align-items: center;
    gap: 12px;
    flex-wrap: wrap;
  }

  .row-left,
  .row-right {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    align-items: center;
  }
  
  .row-left {
    flex: 1 1 auto;
  }
  
  .row-right {
    flex: 0 1 auto;
  }

  button, input, select {
    border-radius: 4px;
    border: 1px solid #888;
    padding: 4px 6px;
    font-size: 14px;
    box-sizing: border-box;
  }
  
  input[type="number"] {
    max-width: 80px;
  }
  
  input[type="text"]#itemName,
  input[type="text"]#circleName {
    max-width: 120px;
  }
  
  input[type="text"]#pdfHeader {
    max-width: 150px;
  }
  
  button:hover { background: #eee; }

  button.active {
    background: #ddd;
    border-color: #555;
  }

  .toolbar-separator {
    margin: 0 8px;
    color: #666;
  }

  #main {
    flex: 1;
    display: flex;
    flex-direction: row;
    overflow: hidden;
  }

  #canvasContainer {
    flex: 1;
    min-width: 300px;
    border-right: 1px solid #ccc;
    background: #fff;
    display: flex;
    position: relative;
  }

  #layoutCanvas {
    flex: 1;
    display: block;
    width: 100%;
    height: 100%;
    outline: none;
  }

  #sidebar {
    width: 260px;
    flex-shrink: 0;
    background: #f9f9f9;
    border-left: 1px solid #ccc;
    padding: 12px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  #sidebar h3 {
    font-size: 16px;
    margin: 0 0 6px 0;
  }

  #sidebar input[type="text"],
  #sidebar input[type="number"] {
    width: 100%;
    padding: 4px;
    margin-bottom: 6px;
    font-size: 13px;
  }

  #sidebar button {
    width: 100%;
    padding: 6px;
    margin-top: 4px;
    font-size: 13px;
  }

  #sidebar .danger {
    border-color: #b00;
    color: #b00;
  }

  .hint {
    padding: 6px 10px;
    font-size: 12px;
    color: #444;
    border-top: 1px solid #ddd;
    background: #fafafa;
  }

  @media print {
    header, .controls, #sidebar, .hint {
      display: none !important;
    }
    #canvasContainer {
      border: none;
    }
    #layoutCanvas {
      width: auto !important;
      height: auto !important;
    }
  }
</style>
</head>
<body>

<header>Shop Layout Planner</header>

<div class="controls">
  <!-- Row 1: Room + Rect -->
  <div class="controls-row">
    <div class="row-left">
      <label>Room W:</label>
      <input type="number" id="roomWidth" value="10" step="any">
      <label>H:</label>
      <input type="number" id="roomHeight" value="10" step="any">
      <select id="roomUnits">
        <option value="ft" selected>Feet</option>
        <option value="m">Meters</option>
      </select>
      <button id="applyRoomBtn">Apply Room</button>
    </div>

    <div class="row-right">
      <label>Rect:</label>
      <input type="text" id="itemName" placeholder="Label" size="10">
      <label>W:</label>
      <input type="number" id="itemWidth" value="3" step="any">
      <label>D:</label>
      <input type="number" id="itemDepth" value="2" step="any">
      <button id="addItemBtn">Add Rect</button>
    </div>
  </div>

  <!-- Row 2: Save/Load/PDF + Circle -->
  <div class="controls-row">
    <div class="row-left">
      <button id="downloadBtn">Download Work in Progress</button>
      <button id="uploadBtn">Upload Work in Progress</button>
      <input type="file" id="fileInput" accept="application/json" style="display:none;">
      <label>PDF Header:</label>
      <input type="text" id="pdfHeader" value="Shop Layout">
      <button id="pdfBtn">Save PDF</button>
    </div>

    <div class="row-right">
      <label>Circle:</label>
      <input type="text" id="circleName" placeholder="Label" size="10">
      <label>Dia:</label>
      <input type="number" id="circleDiameter" value="2" step="any">
      <button id="addCircleBtn">Add Circle</button>
    </div>
  </div>

  <!-- Row 3: Tools + Undo/Redo + Snap -->
  <div class="controls-row">
    <div class="row-left">
      <label>Tool:</label>
      <button id="toolSelectBtn" class="active">Select / Items</button>
      <button id="toolWallBtn">Add Wall</button>
      <button id="toolDoorBtn">Add Door</button>
      <button id="toolWindowBtn">Add Window</button>
      <button id="toolLabelBtn">Add Label</button>

      <span class="toolbar-separator">|</span>

      <button id="undoBtn">Undo</button>
      <button id="redoBtn">Redo</button>

      <button id="snapToggleBtn">Snap: On</button>
    </div>
    <div class="row-right">
      <label>Wall Type:</label>
      <label><input type="radio" name="wallType" value="interior" checked>Interior</label>
      <label><input type="radio" name="wallType" value="exterior">Exterior</label>
    </div>
  </div>
</div>

<div id="main">
  <div id="canvasContainer">
    <canvas id="layoutCanvas" tabindex="0"></canvas>
  </div>

  <div id="sidebar">
    <h3 id="sidebarTitle">Nothing Selected</h3>

    <div id="noSelection"><p>No item, wall, door, window, or label selected.</p></div>

    <!-- Item editor -->
    <div id="itemEditor" style="display:none;">
      <label>Name:</label>
      <input type="text" id="editName">

      <div id="rectFields">
        <label>Width:</label>
        <input type="number" id="editWidth" step="any">
        <label>Depth:</label>
        <input type="number" id="editDepth" step="any">
        <label>Rotation (deg):</label>
        <input type="number" id="editRotation" step="any">
      </div>

      <div id="circleFields" style="display:none;">
        <label>Diameter:</label>
        <input type="number" id="editDiameter" step="any">
      </div>

      <div id="colorFields">
        <label>Color:</label><br>
        <label><input type="radio" name="editColor" value="blue" checked>Blue</label>
        <label><input type="radio" name="editColor" value="green">Green</label>
        <label><input type="radio" name="editColor" value="orange">Orange</label>
        <label><input type="radio" name="editColor" value="gray">Gray</label>
      </div>

      <button id="applyEditBtn">Apply Changes</button>
      <button id="deleteItemBtn" class="danger">Delete Item</button>
    </div>

    <!-- Wall editor -->
    <div id="wallEditor" style="display:none;">
      <label>Wall Type:</label><br>
      <label><input type="radio" name="wallEditType" value="interior">Interior</label><br>
      <label><input type="radio" name="wallEditType" value="exterior">Exterior</label><br><br>

      <button id="applyWallEditBtn">Apply Changes</button>
      <button id="deleteWallBtn" class="danger">Delete Wall</button>
    </div>

    <!-- Door editor -->
    <div id="doorEditor" style="display:none;">
      <label>Door Width:</label>
      <input type="number" id="editDoorWidth" step="any">

      <label>Swing:</label><br>
      <label><input type="radio" name="doorSwing" value="none" checked>None</label><br>
      <label><input type="radio" name="doorSwing" value="in-left">Inward – Left</label><br>
      <label><input type="radio" name="doorSwing" value="in-right">Inward – Right</label><br>
      <label><input type="radio" name="doorSwing" value="out-left">Outward – Left</label><br>
      <label><input type="radio" name="doorSwing" value="out-right">Outward – Right</label><br><br>

      <button id="applyDoorEditBtn">Apply Changes</button>
      <button id="deleteDoorBtn" class="danger">Delete Door</button>
    </div>

    <!-- Window editor -->
    <div id="windowEditor" style="display:none;">
      <label>Window Width:</label>
      <input type="number" id="editWindowWidth" step="any">

      <button id="applyWindowEditBtn">Apply Changes</button>
      <button id="deleteWindowBtn" class="danger">Delete Window</button>
    </div>

    <!-- Label editor -->
    <div id="labelEditor" style="display:none;">
      <label>Text:</label>
      <input type="text" id="editLabelText">

      <label>Size:</label><br>
      <label><input type="radio" name="labelSize" value="small">Small</label><br>
      <label><input type="radio" name="labelSize" value="medium" checked>Medium</label><br>
      <label><input type="radio" name="labelSize" value="large">Large</label><br><br>

      <label>Color:</label><br>
      <label><input type="radio" name="labelColor" value="black" checked>Black</label><br>
      <label><input type="radio" name="labelColor" value="gray">Gray</label><br>
      <label><input type="radio" name="labelColor" value="blue">Blue</label><br><br>

      <button id="applyLabelEditBtn">Apply Changes</button>
      <button id="deleteLabelBtn" class="danger">Delete Label</button>
    </div>

  </div>
</div>

<div class="hint">
  Rectangles & circles: click to select, drag to move, use [ and ] to rotate rectangles.  
  Walls: choose "Add Wall", move cursor to see snap point, click start (snaps), move to see preview, click end.  
  Doors & windows: choose "Add Door"/"Add Window", click near wall to place, drag along wall; edit in sidebar.  
  Labels: choose "Add Label" and click; drag to move and edit in sidebar.  
  Right-click + drag = pan. Mouse wheel = zoom.  
  Undo: Ctrl/Cmd+Z. Redo: Ctrl/Cmd+Shift+Z. PDF always shows the full room (including dimensions).
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>
/* ---------- Core Data ---------- */
const canvas = document.getElementById("layoutCanvas");
const ctx = canvas.getContext("2d");

let room = { width: 10, height: 10, units: "ft" };
let baseScale = 10;
const padding = 30;

let items = [];
let walls = [];
let labels = [];
let doors = [];
let windowsArr = [];

let nextItemId = 1;
let nextWallId = 1;
let nextLabelId = 1;
let nextDoorId = 1;
let nextWindowId = 1;

let selectedItemId = null;
let selectedWallId = null;
let selectedLabelId = null;
let selectedDoorId = null;
let selectedWindowId = null;

let isDragging = false;
let dragItemId = null;
let dragOffset = { x:0, y:0 };

let isRotating = false;
let rotateItemId = null;
let rotateStartAngle = 0;
let rotateStartMouseAngle = 0;

let wallDragMode = null;
let wallDragData = null;

let labelDragId = null;
let labelDragOffset = { x:0, y:0 };

let doorDragId = null;
let windowDragId = null;

let isDirty = false;

/* History for Undo/Redo */
let history = [];
let historyIndex = -1;
const maxHistory = 100;

/* View */
let viewScale = 1;
let offsetX = 0;
let offsetY = 0;
let isPanning = false;
let panLastX = 0;
let panLastY = 0;

/* Tools */
let toolMode = "select";
let wallDraftStart = null;
let wallPreviewCurrent = null;
let currentSnapPoint = null;
let snapToGridEnabled = true;
let didDragThisInteraction = false;

/* ---------- Dirty + History ---------- */

function markDirty() {
  isDirty = true;
}

function markClean() {
  isDirty = false;
}

window.addEventListener("beforeunload", (e)=>{
  if (!isDirty) return;
  e.preventDefault();
  e.returnValue = "";
});

function snapshotState() {
  return JSON.parse(JSON.stringify({
    room, items, walls, labels, doors, windowsArr,
    nextItemId, nextWallId, nextLabelId, nextDoorId, nextWindowId
  }));
}

function pushHistory() {
  const snap = snapshotState();
  if (historyIndex < history.length - 1) {
    history = history.slice(0, historyIndex + 1);
  }
  history.push(snap);
  if (history.length > maxHistory) {
    history.shift();
  }
  historyIndex = history.length - 1;
}

function loadSnapshot(snap) {
  room = snap.room;
  items = snap.items || [];
  walls = snap.walls || [];
  labels = snap.labels || [];
  doors = snap.doors || [];
  windowsArr = snap.windowsArr || [];
  nextItemId = snap.nextItemId || 1;
  nextWallId = snap.nextWallId || 1;
  nextLabelId = snap.nextLabelId || 1;
  nextDoorId = snap.nextDoorId || 1;
  nextWindowId = snap.nextWindowId || 1;

  computeBaseScale();
  selectedItemId = null;
  selectedWallId = null;
  selectedLabelId = null;
  selectedDoorId = null;
  selectedWindowId = null;
  draw();
  updateSidebar();
}

function undo() {
  if (historyIndex <= 0) return;
  historyIndex--;
  loadSnapshot(history[historyIndex]);
  markDirty();
}

function redo() {
  if (historyIndex >= history.length - 1) return;
  historyIndex++;
  loadSnapshot(history[historyIndex]);
  markDirty();
}

/* ---------- Helpers ---------- */

canvas.addEventListener("contextmenu", e => e.preventDefault());

function getMinorGridStep() {
  return room.units === "m" ? 0.1 : 0.25;
}
function getMajorGridStep() {
  return room.units === "m" ? 0.5 : 1.0;
}
function snapToGridValue(v) {
  const step = getMinorGridStep();
  return Math.round(v / step) * step;
}

function resizeCanvas() {
  const rect = document.getElementById("canvasContainer").getBoundingClientRect();
  canvas.width = rect.width;
  canvas.height = rect.height;
  computeBaseScale();
  draw();
}

function computeBaseScale() {
  const usableW = canvas.width - padding*2;
  const usableH = canvas.height - padding*2;
  baseScale = Math.min(usableW / room.width, usableH / room.height);
}

function effectiveScale() {
  return baseScale * viewScale;
}

function roomToCanvas(x,y) {
  const s = effectiveScale();
  return {
    x: padding + offsetX + x * s,
    y: padding + offsetY + y * s
  };
}

function canvasToRoom(x,y) {
  const s = effectiveScale();
  return {
    x: (x - padding - offsetX) / s,
    y: (y - padding - offsetY) / s
  };
}

/* ---------- Colors & Fonts ---------- */

function getItemFillColor(color) {
  switch(color) {
    case "green":  return "#d6f5d6";
    case "orange": return "#ffe0b3";
    case "gray":   return "#e0e0e0";
    case "blue":
    default:       return "#d5e8ff";
  }
}
function getItemStrokeColor(color) {
  switch(color) {
    case "green":  return "#3c7a3c";
    case "orange": return "#b36b00";
    case "gray":   return "#555555";
    case "blue":
    default:       return "#555555";
  }
}
function getLabelFont(label) {
  switch(label.size) {
    case "small": return "12px system-ui";
    case "large": return "20px system-ui";
    case "medium":
    default:       return "14px system-ui";
  }
}

/* ---------- Drawing ---------- */

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawRoom(ctx, roomToCanvas, effectiveScale());
  drawGrid(ctx, roomToCanvas);
  drawWalls(ctx, roomToCanvas);
  drawItems(ctx, roomToCanvas);
  drawLabels(ctx, roomToCanvas);
  drawDimensions(ctx, roomToCanvas);
  drawWallPreview(ctx, roomToCanvas);
  drawSnapPreview(ctx, roomToCanvas);
}

function drawRoom(c, toCanvas, effScale) {
  // Room outline is drawn by perimeter walls, not needed here
  // const tl = toCanvas(0,0);
  // const br = toCanvas(room.width, room.height);
  // c.strokeStyle = "#000";
  // c.lineWidth = 2;
  // c.strokeRect(tl.x, tl.y, br.x - tl.x, br.y - tl.y);
}

function drawGrid(c, toCanvas) {
  const major = getMajorGridStep();
  const minor = getMinorGridStep();
  c.save();

  c.strokeStyle = "#eee";
  c.beginPath();
  for (let x=0; x<=room.width+1e-6; x+=minor) {
    const p1 = toCanvas(x,0), p2 = toCanvas(x,room.height);
    c.moveTo(p1.x, p1.y); c.lineTo(p2.x, p2.y);
  }
  for (let y=0; y<=room.height+1e-6; y+=minor) {
    const p1 = toCanvas(0,y), p2 = toCanvas(room.width,y);
    c.moveTo(p1.x, p1.y); c.lineTo(p2.x, p2.y);
  }
  c.stroke();

  c.strokeStyle = "#ccc";
  c.beginPath();
  for (let x=0; x<=room.width+1e-6; x+=major) {
    const p1 = toCanvas(x,0), p2 = toCanvas(x,room.height);
    c.moveTo(p1.x, p1.y); c.lineTo(p2.x, p2.y);
  }
  for (let y=0; y<=room.height+1e-6; y+=major) {
    const p1 = toCanvas(0,y), p2 = toCanvas(room.width,y);
    c.moveTo(p1.x, p1.y); c.lineTo(p2.x, p2.y);
  }
  c.stroke();

  c.restore();
}

/* ----- Walls, Doors, Windows (with openings) ----- */

function drawWalls(c, toCanvas) {
  walls.forEach(wall => {
    const wallDoors = doors.filter(d => d.wallId === wall.id);
    const wallWindows = windowsArr.filter(w => w.wallId === wall.id);
    drawWallWithOpenings(c, toCanvas, wall, wallDoors, wallWindows);
  });
}

function drawWallWithOpenings(c, toCanvas, wall, wallDoors, wallWindows) {
  const p1W = {x: wall.x1, y: wall.y1};
  const p2W = {x: wall.x2, y: wall.y2};
  const dx = p2W.x - p1W.x;
  const dy = p2W.y - p1W.y;
  const len = Math.hypot(dx, dy);
  if (len === 0) return;

  const openings = [];

  wallDoors.forEach(door => {
    const half = (door.width / len) / 2;
    let s = door.offset - half;
    let e = door.offset + half;
    s = Math.max(0, Math.min(1, s));
    e = Math.max(0, Math.min(1, e));
    if (e > s) openings.push({ start: s, end: e });
  });
  wallWindows.forEach(win => {
    const half = (win.width / len) / 2;
    let s = win.offset - half;
    let e = win.offset + half;
    s = Math.max(0, Math.min(1, s));
    e = Math.max(0, Math.min(1, e));
    if (e > s) openings.push({ start: s, end: e });
  });

  openings.sort((a,b)=>a.start-b.start);

  let segments = [];
  let cur = 0;
  openings.forEach(op => {
    if (op.start > cur) segments.push({ start: cur, end: op.start });
    cur = Math.max(cur, op.end);
  });
  if (cur < 1) segments.push({ start: cur, end: 1 });

  const isSelected = (wall.id === selectedWallId);
  const scaleFactor = Math.sqrt(viewScale);
  let baseInterior = 2;
  let baseExterior = 4;
  let lineWidth;

  if (wall.style === "exterior") {
    c.strokeStyle = isSelected ? "#f00" : "#000";
    lineWidth = baseExterior * scaleFactor;
    if (isSelected) lineWidth *= 1.3;
  } else {
    c.strokeStyle = isSelected ? "#f00" : "#666";
    lineWidth = baseInterior * scaleFactor;
    if (isSelected) lineWidth *= 1.3;
  }
  c.lineWidth = lineWidth;

  segments.forEach(seg => {
    const s1 = seg.start;
    const s2 = seg.end;
    const wx1 = p1W.x + dx * s1;
    const wy1 = p1W.y + dy * s1;
    const wx2 = p1W.x + dx * s2;
    const wy2 = p1W.y + dy * s2;
    const c1 = toCanvas(wx1, wy1);
    const c2 = toCanvas(wx2, wy2);
    c.beginPath();
    c.moveTo(c1.x, c1.y);
    c.lineTo(c2.x, c2.y);
    c.stroke();
  });

  if (isSelected) {
    const cp1 = toCanvas(wall.x1, wall.y1);
    const cp2 = toCanvas(wall.x2, wall.y2);
    c.fillStyle = "#fff";
    c.strokeStyle = "#f00";
    c.lineWidth = 2;
    [cp1,cp2].forEach(pt=>{
      c.beginPath();
      c.arc(pt.x, pt.y, 6, 0, Math.PI*2);
      c.fill();
      c.stroke();
    });
  }

  // Doors
  wallDoors.forEach(door => {
    drawDoorSymbol(c, toCanvas, wall, door);
  });

  // Windows
  wallWindows.forEach(win => {
    drawWindowSymbol(c, toCanvas, wall, win);
  });
}

function drawDoorSymbol(c, toCanvas, wall, door) {
  if (door.swing === "none") return;
  const x1 = wall.x1, y1 = wall.y1;
  const x2 = wall.x2, y2 = wall.y2;
  const dx = x2 - x1;
  const dy = y2 - y1;
  const len = Math.hypot(dx, dy);
  if (len === 0) return;

  const halfFrac = (door.width / len) / 2;
  let s = door.offset - halfFrac;
  let e = door.offset + halfFrac;
  s = Math.max(0, Math.min(1, s));
  e = Math.max(0, Math.min(1, e));
  if (e <= s) return;

  const startX = x1 + dx * s;
  const startY = y1 + dy * s;
  const endX   = x1 + dx * e;
  const endY   = y1 + dy * e;

  let hingeX, hingeY, leafX, leafY;
  if (door.swing.endsWith("left")) {
    hingeX = startX; hingeY = startY;
    leafX  = endX;   leafY  = endY;
  } else {
    hingeX = endX;   hingeY = endY;
    leafX  = startX; leafY  = startY;
  }

  const hingeCanvas = toCanvas(hingeX, hingeY);
  const leafCanvas  = toCanvas(leafX, leafY);
  const leafRadius  = Math.hypot(leafCanvas.x - hingeCanvas.x,
                                 leafCanvas.y - hingeCanvas.y);

  const baseAngle = Math.atan2(leafCanvas.y - hingeCanvas.y,
                               leafCanvas.x - hingeCanvas.x);
  const sweep = Math.PI/2;
  let direction = 1;
  if (door.swing === "in-left" || door.swing === "out-right") {
    direction = 1;
  } else if (door.swing === "in-right" || door.swing === "out-left") {
    direction = -1;
  }

  const startAngle = baseAngle;
  const endAngle   = baseAngle + direction * sweep;

  c.save();
  c.strokeStyle = "#888";
  c.lineWidth = 1;

  // Draw the door panel as a thin line to show door position
  c.beginPath();
  c.moveTo(hingeCanvas.x, hingeCanvas.y);
  c.lineTo(leafCanvas.x, leafCanvas.y);
  c.stroke();

  // Draw the swing arc
  c.strokeStyle = "#444";
  c.lineWidth = 1.4;
  c.beginPath();
  c.arc(hingeCanvas.x, hingeCanvas.y, leafRadius,
        startAngle, endAngle, direction < 0);
  c.stroke();

  c.restore();
}

function drawWindowSymbol(c, toCanvas, wall, win) {
  const x1 = wall.x1, y1 = wall.y1;
  const x2 = wall.x2, y2 = wall.y2;
  const dx = x2 - x1;
  const dy = y2 - y1;
  const len = Math.hypot(dx, dy);
  if (len === 0) return;

  const centerX = x1 + dx * win.offset;
  const centerY = y1 + dy * win.offset;
  const s = effectiveScale();
  const half = (win.width * s) / 2;

  const wallAngle = Math.atan2(dy, dx);
  const centerCanvas = toCanvas(centerX, centerY);

  c.save();
  c.translate(centerCanvas.x, centerCanvas.y);
  c.rotate(wallAngle);

  const h = 6;
  c.fillStyle = "#cce6ff";
  c.strokeStyle = (win.id === selectedWindowId ? "#06c" : "#004488");
  c.lineWidth = 1.5;
  c.beginPath();
  c.rect(-half, -h/2, win.width * s, h);
  c.fill();
  c.stroke();

  c.restore();
}

/* ----- Items ----- */

function drawItems(c, toCanvas) {
  items.forEach(item => {
    if (item.type === "circle") drawCircleItem(c, toCanvas, item);
    else drawRectItem(c, toCanvas, item);
  });
}

function drawRectItem(c, toCanvas, item) {
  const center = toCanvas(item.x, item.y);
  const s = effectiveScale();
  const w = item.width * s;
  const h = item.depth * s;

  const fillCol = getItemFillColor(item.color);
  const strokeCol = getItemStrokeColor(item.color);

  c.save();
  c.translate(center.x, center.y);
  c.rotate(item.rotation || 0);

  c.fillStyle = fillCol;
  c.strokeStyle = (item.id === selectedItemId ? "#06c" : strokeCol);
  c.lineWidth = (item.id === selectedItemId ? 2 : 1.2);
  c.fillRect(-w/2, -h/2, w, h);
  c.strokeRect(-w/2, -h/2, w, h);

  c.save();
  c.rotate(-(item.rotation || 0));
  c.fillStyle = "#000";
  c.font = "13px system-ui";
  c.textAlign = "center";
  c.textBaseline = "middle";
  c.fillText(item.name, 0, 0);
  c.restore();

  c.restore();

  if (item.id === selectedItemId) drawRotateHandle(c, toCanvas, item);
}

function drawCircleItem(c, toCanvas, item) {
  const center = toCanvas(item.x, item.y);
  const s = effectiveScale();
  const r = (item.diameter/2) * s;

  const fillCol = getItemFillColor(item.color);
  const strokeCol = getItemStrokeColor(item.color);

  c.save();
  c.beginPath();
  c.arc(center.x, center.y, r, 0, Math.PI*2);
  c.fillStyle = fillCol;
  c.fill();
  c.strokeStyle = (item.id === selectedItemId ? "#06c" : strokeCol);
  c.lineWidth = (item.id === selectedItemId ? 2 : 1.2);
  c.stroke();

  c.fillStyle = "#000";
  c.font = "13px system-ui";
  c.textAlign = "center";
  c.textBaseline = "middle";
  c.fillText(item.name, center.x, center.y);
  c.restore();
}

/* ----- Labels ----- */

function drawLabels(c, toCanvas) {
  c.save();
  c.textAlign = "center";
  c.textBaseline = "middle";

  labels.forEach(label => {
    const p = toCanvas(label.x, label.y);
    c.font = getLabelFont(label);
    c.fillStyle = label.color || "#444";
    c.fillText(label.text, p.x, p.y);

    if (label.id === selectedLabelId) {
      const padding = 4;
      const w = c.measureText(label.text).width + padding*2;
      const h = 20;
      c.strokeStyle = "#f00";
      c.lineWidth = 1;
      c.strokeRect(p.x - w/2, p.y - h/2, w, h);
    }
  });

  c.restore();
}

/* ----- Dimensions ----- */

function drawDimensions(c, toCanvas) {
  c.save();
  c.strokeStyle = "#999";
  c.fillStyle = "#555";
  c.lineWidth = 1;
  c.font = "12px system-ui";
  c.textAlign = "center";
  c.textBaseline = "middle";

  const tl = toCanvas(0,0);
  const tr = toCanvas(room.width,0);
  const bl = toCanvas(0,room.height);

  const yOff = tl.y - 20;
  c.beginPath();
  c.moveTo(tl.x, yOff);
  c.lineTo(tr.x, yOff);
  c.stroke();

  const arrow = 5;
  c.beginPath();
  c.moveTo(tl.x, yOff);
  c.lineTo(tl.x + arrow, yOff - arrow);
  c.moveTo(tl.x, yOff);
  c.lineTo(tl.x + arrow, yOff + arrow);
  c.moveTo(tr.x, yOff);
  c.lineTo(tr.x - arrow, yOff - arrow);
  c.moveTo(tr.x, yOff);
  c.lineTo(tr.x - arrow, yOff + arrow);
  c.stroke();

  const wText = room.width.toFixed(2) + " " + room.units;
  c.fillText(wText, (tl.x + tr.x)/2, yOff - 10);

  const xOff = tl.x - 20;
  c.beginPath();
  c.moveTo(xOff, tl.y);
  c.lineTo(xOff, bl.y);
  c.stroke();

  c.beginPath();
  c.moveTo(xOff, tl.y);
  c.lineTo(xOff - arrow, tl.y + arrow);
  c.moveTo(xOff, tl.y);
  c.lineTo(xOff + arrow, tl.y + arrow);
  c.moveTo(xOff, bl.y);
  c.lineTo(xOff - arrow, bl.y - arrow);
  c.moveTo(xOff, bl.y);
  c.lineTo(xOff + arrow, bl.y - arrow);
  c.stroke();

  const hText = room.height.toFixed(2) + " " + room.units;
  c.save();
  c.translate(xOff - 15, (tl.y + bl.y)/2);
  c.rotate(-Math.PI/2);
  c.fillText(hText, 0, 0);
  c.restore();

  c.restore();
}

/* ----- Wall Preview & Snap Preview ----- */

function drawWallPreview(c, toCanvas) {
  if (!wallDraftStart || !wallPreviewCurrent) return;
  const p1 = toCanvas(wallDraftStart.x, wallDraftStart.y);
  const p2 = toCanvas(wallPreviewCurrent.x, wallPreviewCurrent.y);
  c.save();
  c.strokeStyle = "rgba(0,0,0,0.5)";
  c.setLineDash([5,4]);
  c.lineWidth = 1;
  c.beginPath();
  c.moveTo(p1.x, p1.y);
  c.lineTo(p2.x, p2.y);
  c.stroke();
  c.setLineDash([]);
  c.restore();
}

function drawSnapPreview(c, toCanvas) {
  if (toolMode !== "wall" || !currentSnapPoint) return;
  const p = toCanvas(currentSnapPoint.x, currentSnapPoint.y);
  c.save();
  c.fillStyle = "#ff8800";
  c.strokeStyle = "#cc6600";
  c.lineWidth = 1.5;
  c.beginPath();
  c.arc(p.x, p.y, 5, 0, Math.PI*2);
  c.fill();
  c.stroke();
  c.restore();
}

/* ----- Rotate Handle ----- */

function drawRotateHandle(c, toCanvas, item) {
  if (item.type !== "rect") return;
  const center = toCanvas(item.x, item.y);
  const s = effectiveScale();
  const h = item.depth * s;
  const half = h/2, offset = 20;
  const L = half + offset;
  const a = item.rotation || 0;

  const hx = center.x + L*Math.sin(a);
  const hy = center.y - L*Math.cos(a);

  c.save();
  c.fillStyle = "#fff";
  c.strokeStyle = "#06c";
  c.lineWidth = 2;

  c.beginPath();
  c.arc(hx, hy, 7, 0, Math.PI*2);
  c.fill();
  c.stroke();

  c.beginPath();
  c.moveTo(center.x, center.y);
  c.lineTo(hx, hy);
  c.stroke();

  c.restore();
}

/* ---------- Hit Testing ---------- */

function isRotateHandle(px,py,item) {
  if (item.type !== "rect") return false;
  const c = roomToCanvas(item.x, item.y);
  const s = effectiveScale();
  const h = item.depth*s;
  const half = h/2, offset = 20;
  const L = half+offset;
  const a = item.rotation || 0;
  const hx = c.x + L*Math.sin(a);
  const hy = c.y - L*Math.cos(a);
  return Math.hypot(px-hx, py-hy) <= 10;
}

function isInsideItem(px,py,item) {
  if (item.type === "circle") {
    const c = roomToCanvas(item.x,item.y);
    const s = effectiveScale();
    const r = (item.diameter/2)*s;
    return Math.hypot(px-c.x, py-c.y) <= r;
  } else {
    const c = roomToCanvas(item.x,item.y);
    let dx = px - c.x, dy = py - c.y;
    const a = item.rotation || 0;
    const cos = Math.cos(-a), sin = Math.sin(-a);
    const x = dx*cos - dy*sin;
    const y = dx*sin + dy*cos;
    const s = effectiveScale();
    const hw = item.width*s/2, hh = item.depth*s/2;
    return (x>=-hw && x<=hw && y>=-hh && y<=hh);
  }
}

function getHit(px,py) {
  for (let i=items.length-1; i>=0; i--) {
    const item = items[i];
    if (item.type === "rect" && isRotateHandle(px,py,item)) {
      return {item,mode:"rotate"};
    }
    if (isInsideItem(px,py,item)) {
      return {item,mode:"move"};
    }
  }
  return null;
}

/* Wall intersections for snapping */

function segmentIntersectionWorld(w1, w2) {
  const x1=w1.x1,y1=w1.y1,x2=w1.x2,y2=w1.y2;
  const x3=w2.x1,y3=w2.y1,x4=w2.x2,y4=w2.y2;
  const denom = (x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);
  if (Math.abs(denom)<1e-9) return null;
  const t = ((x1-x3)*(y3-y4)-(y1-y3)*(x3-x4))/denom;
  const u = ((x1-x3)*(y1-y2)-(y1-y3)*(x1-x2))/denom;
  if (t<0||t>1||u<0||u>1) return null;
  return { x: x1 + t*(x2-x1), y: y1 + t*(y2-y1) };
}

/* Snapping helper */

function getSnappedPoint(world, px, py, mode) {
  const useGrid = snapToGridEnabled;
  let basePoint = useGrid
    ? { x: snapToGridValue(world.x), y: snapToGridValue(world.y) }
    : { x: world.x, y: world.y };

  if (mode !== "wall" && mode !== "wallEnd") return basePoint;

  const snapRadiusPx = 12;
  let bestPoint = null;
  let bestDist = Infinity;

  function consider(cx,cy) {
    const cc = roomToCanvas(cx,cy);
    const d = Math.hypot(cc.x-px, cc.y-py);
    if (d < snapRadiusPx && d < bestDist) {
      bestDist = d;
      bestPoint = {x:cx,y:cy};
    }
  }

  walls.forEach(w=>{
    consider(w.x1,w.y1);
    consider(w.x2,w.y2);
  });

  const n = walls.length;
  for (let i=0;i<n;i++) {
    for (let j=i+1;j<n;j++) {
      const p = segmentIntersectionWorld(walls[i], walls[j]);
      if (p) consider(p.x,p.y);
    }
  }

  return bestPoint || basePoint;
}

/* Hit tests for walls, doors, windows, labels */

function hitTestWall(px,py) {
  const endR = 10;
  const lineThresh = 6;

  for (let i=walls.length-1; i>=0; i--) {
    const wall = walls[i];
    const p1 = roomToCanvas(wall.x1, wall.y1);
    const p2 = roomToCanvas(wall.x2, wall.y2);

    if (Math.hypot(px-p1.x, py-p1.y) <= endR) {
      return {wall, mode:"end1"};
    }
    if (Math.hypot(px-p2.x, py-p2.y) <= endR) {
      return {wall, mode:"end2"};
    }

    const dx = p2.x-p1.x, dy = p2.y-p1.y;
    const len2 = dx*dx+dy*dy;
    if (len2===0) continue;
    let t = ((px-p1.x)*dx + (py-p1.y)*dy)/len2;
    t = Math.max(0,Math.min(1,t));
    const projX = p1.x + t*dx;
    const projY = p1.y + t*dy;
    const dist = Math.hypot(px-projX, py-projY);
    if (dist <= lineThresh) return {wall, mode:"line"};
  }
  return null;
}

function hitTestDoor(px,py) {
  const radius = 16;
  for (let i=doors.length-1; i>=0; i--) {
    const door = doors[i];
    const wall = walls.find(w=>w.id===door.wallId);
    if (!wall) continue;
    const x1=wall.x1,y1=wall.y1,x2=wall.x2,y2=wall.y2;
    const dx=x2-x1, dy=y2-y1;
    const cx = x1 + dx*door.offset;
    const cy = y1 + dy*door.offset;
    const c = roomToCanvas(cx,cy);
    if (Math.hypot(px-c.x,py-c.y) <= radius) return door;
  }
  return null;
}

function hitTestWindow(px,py) {
  const radius = 16;
  for (let i=windowsArr.length-1; i>=0; i--) {
    const win = windowsArr[i];
    const wall = walls.find(w=>w.id===win.wallId);
    if (!wall) continue;
    const x1=wall.x1,y1=wall.y1,x2=wall.x2,y2=wall.y2;
    const dx=x2-x1, dy=y2-y1;
    const cx = x1 + dx*win.offset;
    const cy = y1 + dy*win.offset;
    const c = roomToCanvas(cx,cy);
    if (Math.hypot(px-c.x,py-c.y) <= radius) return win;
  }
  return null;
}

function hitTestLabel(px,py) {
  const radius = 10;
  for (let i=labels.length-1; i>=0; i--) {
    const label = labels[i];
    const p = roomToCanvas(label.x,label.y);
    if (Math.hypot(px-p.x,py-p.y) <= radius) return label;
  }
  return null;
}

/* ---------- Tool Buttons ---------- */

const toolSelectBtn = document.getElementById("toolSelectBtn");
const toolWallBtn   = document.getElementById("toolWallBtn");
const toolDoorBtn   = document.getElementById("toolDoorBtn");
const toolWindowBtn = document.getElementById("toolWindowBtn");
const toolLabelBtn  = document.getElementById("toolLabelBtn");
const snapToggleBtn = document.getElementById("snapToggleBtn");
const undoBtn = document.getElementById("undoBtn");
const redoBtn = document.getElementById("redoBtn");

function setToolMode(mode) {
  toolMode = mode;
  wallDraftStart = null;
  wallPreviewCurrent = null;
  currentSnapPoint = null;

  toolSelectBtn.classList.remove("active");
  toolWallBtn.classList.remove("active");
  toolDoorBtn.classList.remove("active");
  toolWindowBtn.classList.remove("active");
  toolLabelBtn.classList.remove("active");

  if (mode==="select") toolSelectBtn.classList.add("active");
  if (mode==="wall")   toolWallBtn.classList.add("active");
  if (mode==="door")   toolDoorBtn.classList.add("active");
  if (mode==="window") toolWindowBtn.classList.add("active");
  if (mode==="label")  toolLabelBtn.classList.add("active");

  draw();
}

toolSelectBtn.addEventListener("click",()=>setToolMode("select"));
toolWallBtn.addEventListener("click",()=>setToolMode("wall"));
toolDoorBtn.addEventListener("click",()=>setToolMode("door"));
toolWindowBtn.addEventListener("click",()=>setToolMode("window"));
toolLabelBtn.addEventListener("click",()=>setToolMode("label"));

snapToggleBtn.addEventListener("click", ()=>{
  snapToGridEnabled = !snapToGridEnabled;
  snapToggleBtn.textContent = snapToGridEnabled ? "Snap: On" : "Snap: Off";
  draw();
});

undoBtn.addEventListener("click", ()=>undo());
redoBtn.addEventListener("click", ()=>redo());

/* ---------- Mouse Events ---------- */

canvas.addEventListener("mousedown", e=>{
  const rect = canvas.getBoundingClientRect();
  const px = e.clientX-rect.left, py = e.clientY-rect.top;

  if (e.button === 2) {
    isPanning = true;
    panLastX = e.clientX;
    panLastY = e.clientY;
    return;
  }
  if (e.button !== 0) return;

  const world = canvasToRoom(px,py);
  didDragThisInteraction = false;

  /* Wall tool */
  if (toolMode==="wall") {
    const snapped = getSnappedPoint(world,px,py,"wall");
    currentSnapPoint = snapped;

    if (!wallDraftStart) {
      wallDraftStart = snapped;
      wallPreviewCurrent = snapped;
    } else {
      const wt = document.querySelector('input[name="wallType"]:checked');
      const style = wt ? wt.value : "interior";
      walls.push({
        id: nextWallId++,
        x1: wallDraftStart.x,
        y1: wallDraftStart.y,
        x2: snapped.x,
        y2: snapped.y,
        style,
        isPerimeter:false
      });
      wallDraftStart = null;
      wallPreviewCurrent = null;
      currentSnapPoint = null;
      markDirty();
      pushHistory();
      setToolMode("select");
    }
    draw();
    return;
  }

  /* Door tool */
  if (toolMode==="door") {
    let nearestWall=null, nearestDist=Infinity, nearestT=0;
    walls.forEach(w=>{
      const p1=roomToCanvas(w.x1,w.y1);
      const p2=roomToCanvas(w.x2,w.y2);
      const dx=p2.x-p1.x, dy=p2.y-p1.y;
      const len2=dx*dx+dy*dy;
      if(len2===0)return;
      let t=((px-p1.x)*dx+(py-p1.y)*dy)/len2;
      t=Math.max(0,Math.min(1,t));
      const projX=p1.x+t*dx, projY=p1.y+t*dy;
      const dist=Math.hypot(px-projX,py-projY);
      if(dist<nearestDist){nearestDist=dist;nearestWall=w;nearestT=t;}
    });
    if(!nearestWall || nearestDist>20){
      alert("Click closer to a wall to place a door.");
      return;
    }
    const wallLen=Math.hypot(nearestWall.x2-nearestWall.x1,nearestWall.y2-nearestWall.y1);
    const defaultWidth=Math.min(3,wallLen);
    const door={
      id:nextDoorId++,
      wallId:nearestWall.id,
      offset:nearestT,
      width:defaultWidth,
      swing:"none"
    };
    doors.push(door);
    selectedDoorId=door.id;
    selectedItemId=selectedWallId=selectedLabelId=selectedWindowId=null;
    markDirty();
    pushHistory();
    setToolMode("select");
    draw();
    updateSidebar();
    return;
  }

  /* Window tool */
  if (toolMode==="window") {
    let nearestWall=null, nearestDist=Infinity, nearestT=0;
    walls.forEach(w=>{
      const p1=roomToCanvas(w.x1,w.y1);
      const p2=roomToCanvas(w.x2,w.y2);
      const dx=p2.x-p1.x, dy=p2.y-p1.y;
      const len2=dx*dx+dy*dy;
      if(len2===0)return;
      let t=((px-p1.x)*dx+(py-p1.y)*dy)/len2;
      t=Math.max(0,Math.min(1,t));
      const projX=p1.x+t*dx, projY=p1.y+t*dy;
      const dist=Math.hypot(px-projX,py-projY);
      if(dist<nearestDist){nearestDist=dist;nearestWall=w;nearestT=t;}
    });
    if(!nearestWall || nearestDist>20){
      alert("Click closer to a wall to place a window.");
      return;
    }
    const wallLen=Math.hypot(nearestWall.x2-nearestWall.x1,nearestWall.x2-nearestWall.x1);
    const defaultWidth=Math.min(3,wallLen || 3);
    const win={
      id:nextWindowId++,
      wallId:nearestWall.id,
      offset:nearestT,
      width:defaultWidth
    };
    windowsArr.push(win);
    selectedWindowId=win.id;
    selectedDoorId=selectedItemId=selectedWallId=selectedLabelId=null;
    markDirty();
    pushHistory();
    setToolMode("select");
    draw();
    updateSidebar();
    return;
  }

  /* Label tool */
  if (toolMode==="label") {
    const text = prompt("Label text:","Label");
    if (text && text.trim()!=="") {
      labels.push({
        id:nextLabelId++,
        text:text.trim(),
        x:world.x,
        y:world.y,
        size:"medium",
        color:"black"
      });
      markDirty();
      pushHistory();
      draw();
    }
    setToolMode("select");
    return;
  }

  /* Select / drag */
  const hit = getHit(px,py);
  if (hit) {
    selectedItemId = hit.item.id;
    selectedWallId = selectedDoorId = selectedLabelId = selectedWindowId = null;
    updateSidebar();
    if (hit.mode==="move") {
      isDragging = true;
      dragItemId = hit.item.id;
      const rp = world;
      dragOffset.x = rp.x - hit.item.x;
      dragOffset.y = rp.y - hit.item.y;
    }
    if (hit.mode==="rotate") {
      isRotating = true;
      rotateItemId = hit.item.id;
      const c = roomToCanvas(hit.item.x,hit.item.y);
      rotateStartMouseAngle = Math.atan2(py-c.y, px-c.x);
      rotateStartAngle = hit.item.rotation || 0;
    }
    draw();
    return;
  }

  const doorHit = hitTestDoor(px,py);
  if (doorHit) {
    selectedDoorId = doorHit.id;
    selectedItemId = selectedWallId = selectedLabelId = selectedWindowId = null;
    doorDragId = doorHit.id;
    updateSidebar();
    draw();
    return;
  }

  const windowHit = hitTestWindow(px,py);
  if (windowHit) {
    selectedWindowId = windowHit.id;
    selectedDoorId = selectedItemId = selectedWallId = selectedLabelId = null;
    windowDragId = windowHit.id;
    updateSidebar();
    draw();
    return;
  }

  const wallHit = hitTestWall(px,py);
  if (wallHit) {
    selectedWallId = wallHit.wall.id;
    selectedItemId = selectedDoorId = selectedLabelId = selectedWindowId = null;
    wallDragMode = wallHit.mode;
    wallDragData = {
      wallId: wallHit.wall.id,
      startWorld: world,
      orig: { x1: wallHit.wall.x1, y1: wallHit.wall.y1,
              x2: wallHit.wall.x2, y2: wallHit.wall.y2 }
    };
    updateSidebar();
    draw();
    return;
  }

  const labelHit = hitTestLabel(px,py);
  if (labelHit) {
    selectedLabelId = labelHit.id;
    selectedItemId = selectedWallId = selectedDoorId = selectedWindowId = null;
    labelDragId = labelHit.id;
    labelDragOffset.x = world.x - labelHit.x;
    labelDragOffset.y = world.y - labelHit.y;
    updateSidebar();
    draw();
    return;
  }

  selectedItemId = selectedWallId = selectedDoorId = selectedLabelId = selectedWindowId = null;
  wallDragMode = null;
  wallDragData = null;
  labelDragId = null;
  doorDragId = null;
  windowDragId = null;
  updateSidebar();
  draw();
});

canvas.addEventListener("mousemove", e=>{
  const rect = canvas.getBoundingClientRect();
  const px = e.clientX-rect.left, py = e.clientY-rect.top;
  const world = canvasToRoom(px,py);

  if (isPanning) {
    const dx = e.clientX - panLastX;
    const dy = e.clientY - panLastY;
    panLastX = e.clientX;
    panLastY = e.clientY;
    offsetX += dx;
    offsetY += dy;
    draw();
    return;
  }

  if (toolMode==="wall" && !wallDraftStart) {
    currentSnapPoint = getSnappedPoint(world,px,py,"wall");
    draw();
    return;
  }

  if (toolMode==="wall" && wallDraftStart) {
    const snapped = getSnappedPoint(world,px,py,"wall");
    wallPreviewCurrent = snapped;
    currentSnapPoint = snapped;
    draw();
    return;
  }

  if (isDragging && dragItemId) {
    const item = items.find(i=>i.id===dragItemId);
    if (item) {
      item.x = world.x - dragOffset.x;
      item.y = world.y - dragOffset.y;
      markDirty();
      didDragThisInteraction = true;
      draw();
      updateSidebar();
    }
    return;
  }

  if (isRotating && rotateItemId) {
    const item = items.find(i=>i.id===rotateItemId);
    if (item && item.type==="rect") {
      const c = roomToCanvas(item.x,item.y);
      const ang = Math.atan2(py-c.y, px-c.x);
      item.rotation = rotateStartAngle + (ang - rotateStartMouseAngle);
      snapRotation(item);
      markDirty();
      didDragThisInteraction = true;
      draw();
      updateSidebar();
    }
    return;
  }

  if (wallDragMode && wallDragData) {
    const wall = walls.find(w=>w.id===wallDragData.wallId);
    if (!wall) return;

    if (wallDragMode==="line") {
      const snapped = getSnappedPoint(world,px,py,"wall");
      const dx = snapped.x - wallDragData.startWorld.x;
      const dy = snapped.y - wallDragData.startWorld.y;
      wall.x1 = wallDragData.orig.x1 + dx;
      wall.y1 = wallDragData.orig.y1 + dy;
      wall.x2 = wallDragData.orig.x2 + dx;
      wall.y2 = wallDragData.orig.y2 + dy;
    } else if (wallDragMode==="end1") {
      const snapped = getSnappedPoint(world,px,py,"wallEnd");
      wall.x1 = snapped.x;
      wall.y1 = snapped.y;
    } else if (wallDragMode==="end2") {
      const snapped = getSnappedPoint(world,px,py,"wallEnd");
      wall.x2 = snapped.x;
      wall.y2 = snapped.y;
    }

    markDirty();
    didDragThisInteraction = true;
    draw();
    return;
  }

  if (labelDragId) {
    const label = labels.find(l=>l.id===labelDragId);
    if (label) {
      label.x = world.x - labelDragOffset.x;
      label.y = world.y - labelDragOffset.y;
      markDirty();
      didDragThisInteraction = true;
      draw();
    }
    return;
  }

  if (doorDragId) {
    const door = doors.find(d=>d.id===doorDragId);
    if (!door) return;
    const wall = walls.find(w=>w.id===door.wallId);
    if (!wall) return;
    const p1=roomToCanvas(wall.x1,wall.y1);
    const p2=roomToCanvas(wall.x2,wall.y2);
    const dx=p2.x-p1.x, dy=p2.y-p1.y;
    const len2=dx*dx+dy*dy;
    if(len2===0)return;
    let t=((px-p1.x)*dx+(py-p1.y)*dy)/len2;
    t=Math.max(0,Math.min(1,t));
    door.offset = t;
    markDirty();
    didDragThisInteraction = true;
    draw();
    updateSidebar();
    return;
  }

  if (windowDragId) {
    const win = windowsArr.find(w=>w.id===windowDragId);
    if (!win) return;
    const wall = walls.find(w=>w.id===win.wallId);
    if (!wall) return;
    const p1=roomToCanvas(wall.x1,wall.y1);
    const p2=roomToCanvas(wall.x2,wall.y2);
    const dx=p2.x-p1.x, dy=p2.y-p1.y;
    const len2=dx*dx+dy*dy;
    if(len2===0)return;
    let t=((px-p1.x)*dx+(py-p1.y)*dy)/len2;
    t=Math.max(0,Math.min(1,t));
    win.offset = t;
    markDirty();
    didDragThisInteraction = true;
    draw();
    updateSidebar();
    return;
  }
});

window.addEventListener("mouseup", e=>{
  if (e.button === 2) {
    isPanning = false;
  }
  if (didDragThisInteraction) {
    pushHistory();
  }
  isDragging=false;
  dragItemId=null;
  isRotating=false;
  rotateItemId=null;
  wallDragMode=null;
  wallDragData=null;
  labelDragId=null;
  doorDragId=null;
  windowDragId=null;
  didDragThisInteraction = false;
});

/* ---------- Zoom ---------- */

canvas.addEventListener("wheel", e=>{
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const px = e.clientX-rect.left, py = e.clientY-rect.top;
  const world = canvasToRoom(px,py);

  const factor = (e.deltaY<0 ? 1.05 : 0.95);
  let newScale = viewScale * factor;
  const minScale = 0.9;
  const maxScale = 6;
  newScale = Math.max(minScale, Math.min(maxScale, newScale));
  viewScale = newScale;

  const s = effectiveScale();
  offsetX = px - padding - world.x*s;
  offsetY = py - padding - world.y*s;

  draw();
},{passive:false});

/* ---------- Rotation snap for rectangles ---------- */

function snapRotation(item) {
  const targets = [0,90,180,270].map(d=>d*Math.PI/180);
  let a = (item.rotation || 0)%(2*Math.PI);
  if (a<0) a+=2*Math.PI;
  let best=a, min=999;
  targets.forEach(t=>{
    let diff=Math.abs(a-t);
    diff=Math.min(diff,2*Math.PI-diff);
    if(diff<min){min=diff;best=t;}
  });
  if (min < 5*Math.PI/180) item.rotation = best;
}

document.addEventListener("keydown", e=>{
  const key = e.key.toLowerCase();
  if ((e.ctrlKey || e.metaKey) && !e.shiftKey && key === "z") {
    e.preventDefault();
    undo();
    return;
  }
  if ((e.ctrlKey || e.metaKey) && e.shiftKey && key === "z") {
    e.preventDefault();
    redo();
    return;
  }

  if (!selectedItemId) return;
  const item = items.find(i=>i.id===selectedItemId);
  if (!item || item.type!=="rect") return;

  const step = 5*Math.PI/180;
  if (key==="[") item.rotation = (item.rotation||0) - step;
  if (key==="]") item.rotation = (item.rotation||0) + step;
  snapRotation(item);
  markDirty();
  pushHistory();
  draw();
  updateSidebar();
});

/* ---------- Add Items & Circles ---------- */

document.getElementById("addItemBtn").addEventListener("click", ()=>{
  const name = document.getElementById("itemName").value || "Label";
  const w = parseFloat(document.getElementById("itemWidth").value);
  const d = parseFloat(document.getElementById("itemDepth").value);
  if (!(w>0 && d>0)) return alert("Invalid rectangle size.");

  const item = {
    id:nextItemId++,
    type:"rect",
    name,
    width:w,
    depth:d,
    x:room.width/2,
    y:room.height/2,
    rotation:0,
    color:"blue"
  };
  items.push(item);
  selectedItemId=item.id;
  selectedWallId=selectedDoorId=selectedLabelId=selectedWindowId=null;
  markDirty();
  pushHistory();
  draw();
  updateSidebar();
});

document.getElementById("addCircleBtn").addEventListener("click", ()=>{
  const name=document.getElementById("circleName").value || "Label";
  const dia=parseFloat(document.getElementById("circleDiameter").value);
  if (!(dia>0)) return alert("Invalid circle diameter.");

  const item={
    id:nextItemId++,
    type:"circle",
    name,
    diameter:dia,
    x:room.width/2,
    y:room.height/2,
    rotation:0,
    color:"blue"
  };
  items.push(item);
  selectedItemId=item.id;
  selectedWallId=selectedDoorId=selectedLabelId=selectedWindowId=null;
  markDirty();
  pushHistory();
  draw(); updateSidebar();
});

/* ---------- Sidebar Update ---------- */

function updateSidebar() {
  const sidebarTitle = document.getElementById("sidebarTitle");
  const noSel   = document.getElementById("noSelection");
  const itemEd  = document.getElementById("itemEditor");
  const wallEd  = document.getElementById("wallEditor");
  const doorEd  = document.getElementById("doorEditor");
  const winEd   = document.getElementById("windowEditor");
  const labelEd = document.getElementById("labelEditor");
  const rectFields = document.getElementById("rectFields");
  const circleFields = document.getElementById("circleFields");

  noSel.style.display   = "block";
  itemEd.style.display  = "none";
  wallEd.style.display  = "none";
  doorEd.style.display  = "none";
  winEd.style.display   = "none";
  labelEd.style.display = "none";
  sidebarTitle.textContent = "Nothing Selected";

  if (selectedItemId) {
    const item = items.find(i=>i.id===selectedItemId);
    if (!item) return;
    noSel.style.display = "none";
    itemEd.style.display = "block";
    sidebarTitle.textContent = "Item Details";
    document.getElementById("editName").value = item.name;

    if (item.type==="rect") {
      rectFields.style.display="block";
      circleFields.style.display="none";
      document.getElementById("editWidth").value = item.width;
      document.getElementById("editDepth").value = item.depth;
      document.getElementById("editRotation").value = ((item.rotation||0)*180/Math.PI).toFixed(2);
    } else {
      rectFields.style.display="none";
      circleFields.style.display="block";
      document.getElementById("editDiameter").value = item.diameter;
    }

    document.querySelectorAll('input[name="editColor"]').forEach(r=>{
      r.checked = (r.value === item.color);
    });
    return;
  }

  if (selectedWallId) {
    const wall = walls.find(w=>w.id===selectedWallId);
    if (!wall) return;
    noSel.style.display = "none";
    wallEd.style.display = "block";
    sidebarTitle.textContent = "Wall Details";
    document.querySelectorAll('input[name="wallEditType"]').forEach(r=>{
      r.checked = (r.value === wall.style);
    });
    return;
  }

  if (selectedDoorId) {
    const door = doors.find(d=>d.id===selectedDoorId);
    if (!door) return;
    noSel.style.display = "none";
    doorEd.style.display = "block";
    sidebarTitle.textContent = "Door Details";
    document.getElementById("editDoorWidth").value = door.width;
    document.querySelectorAll('input[name="doorSwing"]').forEach(r=>{
      r.checked = (r.value === (door.swing||"none"));
    });
    return;
  }

  if (selectedWindowId) {
    const win = windowsArr.find(w=>w.id===selectedWindowId);
    if (!win) return;
    noSel.style.display = "none";
    winEd.style.display = "block";
    sidebarTitle.textContent = "Window Details";
    document.getElementById("editWindowWidth").value = win.width;
    return;
  }

  if (selectedLabelId) {
    const label = labels.find(l=>l.id===selectedLabelId);
    if (!label) return;
    noSel.style.display = "none";
    labelEd.style.display = "block";
    sidebarTitle.textContent = "Label Details";
    document.getElementById("editLabelText").value = label.text;
    document.querySelectorAll('input[name="labelSize"]').forEach(r=>{
      r.checked = (r.value === (label.size||"medium"));
    });
    document.querySelectorAll('input[name="labelColor"]').forEach(r=>{
      r.checked = (r.value === (label.color||"black"));
    });
    return;
  }
}

/* ----- Sidebar: Items ----- */

document.getElementById("applyEditBtn").addEventListener("click", ()=>{
  const item = items.find(i=>i.id===selectedItemId);
  if (!item) return;

  item.name = document.getElementById("editName").value || "Label";

  if (item.type==="rect") {
    let w = parseFloat(document.getElementById("editWidth").value);
    let d = parseFloat(document.getElementById("editDepth").value);
    if (!(w>0)) w=item.width;
    if (!(d>0)) d=item.depth;
    item.width=w; item.depth=d;
    let rDeg=parseFloat(document.getElementById("editRotation").value);
    if (!isNaN(rDeg)) {
      item.rotation = rDeg*Math.PI/180;
      snapRotation(item);
    }
  } else {
    let dia = parseFloat(document.getElementById("editDiameter").value);
    if (!(dia>0)) dia=item.diameter;
    item.diameter=dia;
  }

  const colorInput = document.querySelector('input[name="editColor"]:checked');
  if (colorInput) item.color=colorInput.value;

  markDirty();
  pushHistory();
  draw();
  updateSidebar();
});

document.getElementById("deleteItemBtn").addEventListener("click", ()=>{
  items = items.filter(i=>i.id!==selectedItemId);
  selectedItemId=null;
  markDirty();
  pushHistory();
  draw();
  updateSidebar();
});

/* ----- Sidebar: Walls ----- */

document.getElementById("applyWallEditBtn").addEventListener("click", ()=>{
  const wall = walls.find(w=>w.id===selectedWallId);
  if (!wall) return;
  const r = document.querySelector('input[name="wallEditType"]:checked');
  if (r) wall.style = r.value || "interior";
  markDirty();
  pushHistory();
  draw();
  updateSidebar();
});

document.getElementById("deleteWallBtn").addEventListener("click", ()=>{
  const wallId = selectedWallId;
  walls = walls.filter(w=>w.id!==wallId);
  doors = doors.filter(d=>d.wallId!==wallId);
  windowsArr = windowsArr.filter(w=>w.wallId!==wallId);
  selectedWallId=selectedDoorId=selectedWindowId=null;
  markDirty();
  pushHistory();
  draw();
  updateSidebar();
});

/* ----- Sidebar: Doors ----- */

document.getElementById("applyDoorEditBtn").addEventListener("click", ()=>{
  const door = doors.find(d=>d.id===selectedDoorId);
  if (!door) return;
  let w = parseFloat(document.getElementById("editDoorWidth").value);
  if (!(w>0)) w=door.width;
  door.width=w;
  const swingRadio = document.querySelector('input[name="doorSwing"]:checked');
  if (swingRadio) door.swing=swingRadio.value;
  markDirty();
  pushHistory();
  draw();
  updateSidebar();
});

document.getElementById("deleteDoorBtn").addEventListener("click", ()=>{
  doors = doors.filter(d=>d.id!==selectedDoorId);
  selectedDoorId=null;
  markDirty();
  pushHistory();
  draw();
  updateSidebar();
});

/* ----- Sidebar: Windows ----- */

document.getElementById("applyWindowEditBtn").addEventListener("click", ()=>{
  const win = windowsArr.find(w=>w.id===selectedWindowId);
  if (!win) return;
  let w = parseFloat(document.getElementById("editWindowWidth").value);
  if (!(w>0)) w=win.width;
  win.width=w;
  markDirty();
  pushHistory();
  draw();
  updateSidebar();
});

document.getElementById("deleteWindowBtn").addEventListener("click", ()=>{
  windowsArr = windowsArr.filter(w=>w.id!==selectedWindowId);
  selectedWindowId=null;
  markDirty();
  pushHistory();
  draw();
  updateSidebar();
});

/* ----- Sidebar: Labels ----- */

document.getElementById("applyLabelEditBtn").addEventListener("click", ()=>{
  const label = labels.find(l=>l.id===selectedLabelId);
  if (!label) return;
  label.text = document.getElementById("editLabelText").value || "Label";
  const s = document.querySelector('input[name="labelSize"]:checked');
  if (s) label.size=s.value;
  const c = document.querySelector('input[name="labelColor"]:checked');
  if (c) label.color=c.value;
  markDirty();
  pushHistory();
  draw();
  updateSidebar();
});

document.getElementById("deleteLabelBtn").addEventListener("click", ()=>{
  labels = labels.filter(l=>l.id!==selectedLabelId);
  selectedLabelId=null;
  markDirty();
  pushHistory();
  draw();
  updateSidebar();
});

/* ---------- Room & Perimeter Walls ---------- */

function ensurePerimeterWalls() {
  if (walls.some(w=>w.isPerimeter)) return;
  const W = room.width, H = room.height;
  walls.push(
    { id:nextWallId++, x1:0,y1:0, x2:W,y2:0, style:"exterior", isPerimeter:true, side:"top" },
    { id:nextWallId++, x1:W,y1:0, x2:W,y2:H, style:"exterior", isPerimeter:true, side:"right" },
    { id:nextWallId++, x1:W,y1:H,x2:0,y2:H, style:"exterior", isPerimeter:true, side:"bottom" },
    { id:nextWallId++, x1:0,y1:H,x2:0,y2:0, style:"exterior", isPerimeter:true, side:"left" }
  );
}

function updatePerimeterWallGeometry() {
  const W=room.width, H=room.height;
  walls.forEach(w=>{
    if (!w.isPerimeter) return;
    switch(w.side) {
      case "top":    w.x1=0; w.y1=0; w.x2=W; w.y2=0; break;
      case "right":  w.x1=W; w.y1=0; w.x2=W; w.y2=H; break;
      case "bottom": w.x1=W; w.y1=H; w.x2=0; w.y2=H; break;
      case "left":   w.x1=0; w.y1=H; w.x2=0; w.y2=0; break;
    }
  });
}

document.getElementById("applyRoomBtn").addEventListener("click", ()=>{
  const w=parseFloat(document.getElementById("roomWidth").value);
  const h=parseFloat(document.getElementById("roomHeight").value);
  if (!(w>0 && h>0)) return alert("Invalid room dimensions.");
  room.width=w;
  room.height=h;
  room.units=document.getElementById("roomUnits").value;
  updatePerimeterWallGeometry();
  computeBaseScale();
  markDirty();
  pushHistory();
  draw();
});

/* ---------- JSON Save/Load ---------- */

document.getElementById("downloadBtn").addEventListener("click", ()=>{
  const blob = new Blob(
    [JSON.stringify({
      room,items,walls,labels,doors,windowsArr,
      nextItemId,nextWallId,nextLabelId,nextDoorId,nextWindowId
    },null,2)],
    {type:"application/json"}
  );
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url; a.download="shop_layout.json"; a.click();
  URL.revokeObjectURL(url);
  markClean();
});

const fileInput = document.getElementById("fileInput");
document.getElementById("uploadBtn").addEventListener("click", ()=>fileInput.click());

fileInput.addEventListener("change", e=>{
  const file=e.target.files[0];
  if (!file) return;
  const reader=new FileReader();
  reader.onload=function(evt){
    const obj=JSON.parse(evt.target.result);
    room=obj.room;
    items=obj.items||[];
    walls=obj.walls||[];
    labels=obj.labels||[];
    doors=obj.doors||[];
    windowsArr=obj.windowsArr||[];
    nextItemId=obj.nextItemId||1;
    nextWallId=obj.nextWallId||1;
    nextLabelId=obj.nextLabelId||1;
    nextDoorId=obj.nextDoorId||1;
    nextWindowId=obj.nextWindowId||1;

    items.forEach(it=>{
      if (!it.type) it.type="rect";
      if (!it.color) it.color="blue";
      if (it.type==="rect" && typeof it.rotation!=="number") it.rotation=0;
    });

    labels.forEach(l=>{
      if (!l.size) l.size="medium";
      if (!l.color) l.color="black";
    });

    doors.forEach(d=>{
      if (!d.swing) d.swing="none";
      if (typeof d.width!=="number" || d.width<=0) d.width=3;
      if (typeof d.offset!=="number") d.offset=0.5;
    });

    windowsArr.forEach(w=>{
      if (typeof w.width!=="number" || w.width<=0) w.width=3;
      if (typeof w.offset!=="number") w.offset=0.5;
    });

    computeBaseScale();
    selectedItemId=selectedWallId=selectedDoorId=selectedLabelId=selectedWindowId=null;
    markClean();
    pushHistory();
    draw();
    updateSidebar();
  };
  reader.readAsText(file);
  fileInput.value="";
});

/* ---------- PDF Export ---------- */

document.getElementById("pdfBtn").addEventListener("click", ()=>{
  const { jsPDF } = window.jspdf;
  const headerText = document.getElementById("pdfHeader").value || "Shop Layout";

  const pdf = new jsPDF({
    orientation: room.width >= room.height ? "landscape" : "portrait",
    unit: "pt",
    format: "letter"
  });

  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();

  const headerSpace = 40;
  const availW = pageWidth - 40;
  const availH = pageHeight - headerSpace - 40;

  const aspectRoom = room.width / room.height;
  const aspectPage = availW / availH;
  let drawW, drawH;
  if (aspectRoom > aspectPage) {
    drawW = availW;
    drawH = drawW / aspectRoom;
  } else {
    drawH = availH;
    drawW = drawH * aspectRoom;
  }

  const offCanvas = document.createElement("canvas");
  offCanvas.width = Math.round(drawW);
  offCanvas.height = Math.round(drawH);
  const offCtx = offCanvas.getContext("2d");

  const localPad = 20;
  const s = Math.min(
    (offCanvas.width - 2*localPad) / room.width,
    (offCanvas.height- 2*localPad) / room.height
  );

  function roomToCanvasPdf(x,y){
    return { x: localPad + x*s, y: localPad + y*s };
  }

  offCtx.fillStyle="#fff";
  offCtx.fillRect(0,0,offCanvas.width,offCanvas.height);

  drawRoom(offCtx, roomToCanvasPdf, s);
  drawGrid(offCtx, roomToCanvasPdf);
  drawWalls(offCtx, roomToCanvasPdf);

  offCtx.save();
  const tl = roomToCanvasPdf(0,0);
  const br = roomToCanvasPdf(room.width,room.height);
  offCtx.beginPath();
  offCtx.rect(tl.x, tl.y, br.x-tl.x, br.y-tl.y);
  offCtx.clip();

  drawItems(offCtx, roomToCanvasPdf);
  drawLabels(offCtx, roomToCanvasPdf);
  offCtx.restore();

  drawDimensions(offCtx, roomToCanvasPdf);

  const dataUrl = offCanvas.toDataURL("image/png");

  pdf.setFontSize(14);
  const textWidth = pdf.getTextWidth(headerText);
  pdf.text(headerText, (pageWidth-textWidth)/2, 24);

  const imgX = (pageWidth - drawW)/2;
  const imgY = headerSpace;
  pdf.addImage(dataUrl, "PNG", imgX, imgY, drawW, drawH);

  pdf.save("shop_layout.pdf");
});

/* ---------- Init ---------- */

window.addEventListener("resize", resizeCanvas);
resizeCanvas();
ensurePerimeterWalls();
updatePerimeterWallGeometry();
computeBaseScale();
draw();
updateSidebar();
pushHistory();
markClean();
</script>

</body>
</html>
